<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>Pixel Survivor</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      body {
        font-family: "Outfit", sans-serif;
        background: #111;
        color: #fff;
        overflow: hidden;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }
      #gameContainer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        overflow: hidden;
        border: 4px solid #fff;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
      }
      #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #436b4a; /* Soft grass green */
        image-rendering: pixelated;
      }

      /* UI Overlays */
      .screen {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(5px);
      }
      .screen.active {
        display: flex;
      }

      h1 {
        font-size: 3rem;
        color: #ffab40;
        text-shadow: 0 4px 10px rgba(255, 171, 64, 0.5);
        margin-bottom: 20px;
        text-align: center;
      }

      .btn-main {
        background: linear-gradient(135deg, #ffab40, #ff6d00);
        border: none;
        padding: 15px 40px;
        font-size: 1.5rem;
        font-weight: 800;
        color: #fff;
        border-radius: 30px;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(255, 109, 0, 0.4);
        transition: all 0.2s;
        font-family: inherit;
        text-transform: uppercase;
      }
      .btn-main:hover {
        transform: scale(1.05);
      }

      /* HUD */
      #hud {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 10px;
        z-index: 50;
        pointer-events: none;
        display: none;
        flex-direction: column;
        gap: 10px;
      }
      .hud-top {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .timer {
        font-size: 1.5rem;
        font-weight: bold;
        color: #fff;
        text-shadow: 1px 1px 3px #000;
      }

      /* EXP Bar */
      .exp-container {
        width: 100%;
        height: 12px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 6px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
        position: relative;
      }
      .exp-bar {
        height: 100%;
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        width: 0%;
        transition: width 0.2s;
      }
      .level-text {
        position: absolute;
        top: -20px;
        right: 0;
        font-size: 0.9rem;
        font-weight: bold;
        color: #4facfe;
        text-shadow: 1px 1px 2px #000;
      }

      /* Health Bar Overlay (Above player) */
      /* Drawn in canvas relative to player pos */

      /* Buttons & Joysticks */
      .home-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        text-decoration: none;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 15px;
        border-radius: 20px;
        font-weight: bold;
        color: #fff;
        z-index: 200;
        transition: all 0.2s;
        font-size: 0.9rem;
        pointer-events: auto;
      }

      /* Virtual Joystick */
      #joystick-zone {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 150px;
        height: 150px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        z-index: 200;
        display: none; /* Only show on touch / gameplay */
        pointer-events: auto;
      }
      @media (orientation: portrait) {
        #joystick-zone {
          left: 50%;
          transform: translateX(-50%);
          bottom: 10px;
        }
      }
      #joystick-knob {
        position: absolute;
        top: 50px;
        left: 50px;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        pointer-events: none;
      }
      /* Character Cards */
      .char-card {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 15px;
        text-align: center;
        width: 160px;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
        cursor: pointer;
      }
      .char-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }
      .char-card h3 {
        margin-bottom: 5px;
        font-size: 1.2rem;
      }
      .char-card p {
        font-size: 0.8rem;
        color: #bbb;
        margin-bottom: 10px;
      }
      .price-btn {
        background: #fbc02d;
        color: #333;
        border: none;
        padding: 8px 15px;
        border-radius: 20px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
        margin-top: 5px;
        transition: background 0.2s;
      }
      .price-btn:hover {
        background: #fdd835;
      }
      .play-btn {
        background: #4caf50;
        color: #fff;
        border: none;
        padding: 8px 15px;
        border-radius: 20px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <!-- Title Screen -->
    <div id="titleScreen" class="screen active">
      <a href="index.html" class="home-btn">üè† Home</a>
      <h1>‚öîÔ∏è Pixel Survivor</h1>
      <div
        style="
          color: #ffccbc;
          margin-bottom: 20px;
          font-size: 1.1rem;
          text-shadow: 1px 1px 3px #000;
        "
      >
        üèÜ Best Time: <span id="titleBestTime">00:00</span> | üåü Max Lv:
        <span id="titleBestLevel">1</span>
      </div>
      <div
        class="global-khuno-display"
        style="
          position: absolute;
          top: 15px;
          right: 15px;
          color: #fbc02d;
          font-weight: bold;
          font-size: 1.2rem;
          background: rgba(0, 0, 0, 0.5);
          padding: 5px 15px;
          border-radius: 20px;
          z-index: 100;
        "
      >
        üí∞ Khuno: <span id="titleTotalKhuno">0</span> K
      </div>
      <button class="btn-main" onclick="showCharSelect()">‚ñ∂ Play</button>
      <button
        class="home-btn"
        style="
          position: relative;
          top: auto;
          left: auto;
          margin-top: 20px;
          background: rgba(255, 255, 255, 0.2);
        "
        onclick="toggleModal('howToModal', true)"
      >
        ‚ùì ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô
      </button>
    </div>

    <!-- How to Play Modal -->
    <div id="howToModal" class="screen">
      <div
        style="
          background: #fff;
          color: #333;
          padding: 20px;
          border-radius: 15px;
          max-width: 90%;
          min-width: 300px;
          position: relative;
        "
      >
        <h2 style="margin-bottom: 15px; text-align: center; color: #ff6d00">
          ‚öîÔ∏è ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô Pixel Survivor
        </h2>
        <ul style="line-height: 1.6; margin-left: 20px; margin-bottom: 15px">
          <li>
            ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏î‡πâ‡∏ß‡∏¢ <strong>‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏π‡∏Å‡∏®‡∏£ (W,A,S,D)</strong> ‡∏´‡∏£‡∏∑‡∏≠
            <strong>‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å‡∏à‡∏≥‡∏•‡∏≠‡∏á</strong> ‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
          </li>
          <li>‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏à‡∏∞ <strong>‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÉ‡∏Å‡∏•‡πâ‡∏™‡∏∏‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</strong></li>
          <li>
            ‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡πâ‡∏ß
            <strong>‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡∏±‡∏•‡∏™‡∏µ‡∏ü‡πâ‡∏≤ (EXP)</strong> ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏•‡πÄ‡∏ß‡∏•
          </li>
          <li>
            üí∞ <strong>Khuno (K)</strong>:
            ‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏°‡∏µ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏£‡∏≠‡∏õ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ï‡∏±‡∏ß‡πÄ‡∏Å‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡∏°‡∏≤‡∏™‡∏∞‡∏™‡∏°
            ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÉ‡∏´‡∏°‡πà (Knight, Ranger) ‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏£‡∏Å
          </li>
          <li>
            üéÅ <strong>‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏û‡∏¥‡πÄ‡∏®‡∏©</strong>: ‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏°‡∏µ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏£‡∏≠‡∏õ ‚ù§Ô∏è (‡∏Æ‡∏µ‡∏•), üí£
            (‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏à‡∏≠), ‡∏´‡∏£‡∏∑‡∏≠ üß≤ (‡∏î‡∏π‡∏î‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡∏±‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)
          </li>
          <li>
            ‚ö†Ô∏è <strong>‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ</strong>:
            ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÅ‡∏•‡∏∞‡∏´‡∏¥‡∏ô‡∏à‡∏∞‡∏Ç‡∏ß‡∏≤‡∏á‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡∏∞‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå
          </li>
          <li>
            ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏≠‡∏±‡∏õ ‡∏à‡∏∞‡∏°‡∏µ
            <strong>‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î 3 ‡∏≠‡∏¢‡πà‡∏≤‡∏á</strong>
            ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á
          </li>
          <li>‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏∑‡∏≠: <strong>‡πÄ‡∏≠‡∏≤‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏£‡∏≠‡∏î‡πÉ‡∏´‡πâ‡∏ô‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î!</strong></li>
          <li>
            üö™ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°
            <strong>Exit</strong> ‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏±‡∏ô‡πÑ‡∏î‡πâ
          </li>
        </ul>
        <div style="text-align: center">
          <button
            class="btn-main"
            style="padding: 10px 20px; font-size: 1rem"
            onclick="toggleModal('howToModal', false)"
          >
            ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏•‡πâ‡∏ß!
          </button>
        </div>
      </div>
    </div>

    <!-- Character Select Screen -->
    <div id="charSelectScreen" class="screen">
      <a
        href="index.html"
        class="home-btn"
        style="position: absolute; top: 15px; left: 15px"
        >üè† Home</a
      >
      <h2 style="font-size: 2.5rem; color: #ffab40; margin-bottom: 5px">
        Select Hero
      </h2>
      <div
        class="global-khuno-display"
        style="
          position: absolute;
          top: 15px;
          right: 15px;
          color: #fbc02d;
          font-weight: bold;
          font-size: 1.2rem;
          background: rgba(0, 0, 0, 0.5);
          padding: 5px 15px;
          border-radius: 20px;
          z-index: 100;
        "
      >
        üí∞ Khuno: <span id="charSelectKhuno">0</span> K
      </div>

      <div
        style="
          display: flex;
          gap: 15px;
          flex-wrap: wrap;
          justify-content: center;
          max-width: 600px;
          margin-bottom: 20px;
        "
      >
        <!-- Mage -->
        <div class="char-card">
          <div style="font-size: 3rem; margin-bottom: 10px">üßô‚Äç‚ôÇÔ∏è</div>
          <h3>Mage</h3>
          <p>Auto-fire magic orbs. Balanced.</p>
          <button class="play-btn" onclick="startGame('mage')">Select</button>
        </div>
        <!-- Knight -->
        <div class="char-card">
          <div style="font-size: 3rem; margin-bottom: 10px">üõ°Ô∏è</div>
          <h3>Knight</h3>
          <p>High HP & melee swing attack.</p>
          <button
            class="price-btn"
            id="btn-buy-knight"
            onclick="buyChar('knight', 25)"
          >
            üí∞ 25 K
          </button>
          <button
            class="play-btn"
            id="btn-play-knight"
            style="display: none"
            onclick="startGame('knight')"
          >
            Select
          </button>
        </div>
        <!-- Ranger -->
        <div class="char-card">
          <div style="font-size: 3rem; margin-bottom: 10px">üèπ</div>
          <h3>Ranger</h3>
          <p>Fast speed & rapid-fire arrows.</p>
          <button
            class="price-btn"
            id="btn-buy-ranger"
            onclick="buyChar('ranger', 40)"
          >
            üí∞ 40 K
          </button>
          <button
            class="play-btn"
            id="btn-play-ranger"
            style="display: none"
            onclick="startGame('ranger')"
          >
            Select
          </button>
        </div>
      </div>

      <button
        class="home-btn"
        style="
          position: relative;
          top: auto;
          left: auto;
          background: rgba(255, 255, 255, 0.2);
        "
        onclick="
          toggleModal('charSelectScreen', false);
          toggleModal('titleScreen', true);
        "
      >
        ‚ùå Cancel
      </button>
    </div>

    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <!-- Gameplay HUD -->
      <div id="hud">
        <div class="exp-container">
          <div class="level-text">Lv.<span id="levelText">1</span></div>
          <div class="exp-bar" id="expBar"></div>
        </div>
        <div class="hud-top">
          <div style="display: flex; gap: 15px; align-items: center">
            <div class="timer" id="timeText" style="min-width: 70px">00:00</div>
            <div
              style="
                background: rgba(0, 0, 0, 0.5);
                padding: 5px 10px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.2);
                font-weight: bold;
                color: #fbc02d;
              "
            >
              üí∞ <span id="hudKhuno">0</span>
            </div>
            <div
              style="
                background: rgba(0, 0, 0, 0.5);
                padding: 5px 10px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.2);
              "
            >
              <span style="color: #ff5252; font-weight: bold">‚ù§</span>
              <span id="hpText" style="font-weight: bold">100/100</span>
            </div>
          </div>
          <button
            class="home-btn"
            style="
              position: relative;
              top: 0;
              left: 0;
              background: rgba(244, 67, 54, 0.8);
              border: none;
              cursor: pointer;
            "
            onclick="exitGame()"
          >
            üö™ Exit
          </button>
        </div>
      </div>
    </div>

    <div id="joystick-zone">
      <div id="joystick-knob"></div>
    </div>

    <!-- Level Up Screen -->
    <div id="levelUpScreen" class="screen">
      <h2 style="font-size: 2rem; color: #4facfe; margin-bottom: 20px">
        üéâ LEVEL UP!
      </h2>
      <div
        id="upgradeOptions"
        style="
          display: flex;
          flex-direction: column;
          gap: 15px;
          width: 80%;
          max-width: 400px;
        "
      >
        <!-- Populated via JS -->
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen">
      <h2 style="font-size: 3rem; color: #f44336; margin-bottom: 10px">
        GAME OVER
      </h2>
      <p style="font-size: 1.2rem; margin-bottom: 20px">
        Survived for: <span id="finalTime">00:00</span>
      </p>
      <p style="font-size: 1.2rem; margin-bottom: 20px">
        Reached Level: <span id="finalLevel">1</span>
      </p>
      <p
        id="goKhunoEarned"
        style="
          font-size: 1.5rem;
          color: #fbc02d;
          font-weight: bold;
          margin-bottom: 20px;
          text-shadow: 1px 1px 3px #000;
          display: none;
        "
      >
        üí∞ + 0 K
      </p>
      <div
        style="
          color: #ffccbc;
          margin-bottom: 30px;
          font-size: 1.1rem;
          text-shadow: 1px 1px 3px #000;
        "
      >
        üèÜ Best Time: <span id="goBestTime">00:00</span> | üåü Max Lv:
        <span id="goBestLevel">1</span>
      </div>
      <button class="btn-main" onclick="showCharSelect()">üîÑ Play Again</button>
      <a
        href="index.html"
        class="home-btn"
        style="position: relative; top: auto; left: auto; margin-top: 15px"
        >üè† Home</a
      >
    </div>

    <script>
      // --- Game Constants & State ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let gameState = "title"; // title, playing, levelup, gameover
      let lastTime = 0;
      let gameTime = 0;

      // Persistence
      let globalKhuno = parseInt(localStorage.getItem("khunoCoins") || 0);

      document.addEventListener("DOMContentLoaded", () => {
        const titleEl = document.getElementById("titleTotalKhuno");
        if (titleEl) titleEl.innerText = globalKhuno;
      });

      let ownedChars = JSON.parse(
        localStorage.getItem("pixelSurvivorOwnedChars") || '["mage"]',
      );
      let khunoSessionCoins = 0; // Run money

      // Virtual Camera
      let camera = { x: 0, y: 0 };

      // Inputs
      let keys = {};
      let joystick = { active: false, dx: 0, dy: 0, baseX: 0, baseY: 0 };

      // Entities
      let player;
      let enemies = [];
      let gems = [];
      let items = []; // Special items
      let projectiles = [];
      let damageNumbers = [];
      let obstacles = [];
      const WORLD_SIZE = 2000;

      // --- Classes ---
      class Obstacle {
        constructor() {
          this.x = (Math.random() - 0.5) * WORLD_SIZE;
          this.y = (Math.random() - 0.5) * WORLD_SIZE;
          this.radius = 20 + Math.random() * 20;
          this.type = Math.random() > 0.5 ? "tree" : "rock";
        }
        draw(ctx) {
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y + this.radius * 0.8,
            this.radius,
            this.radius / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          if (this.type === "tree") {
            ctx.fillStyle = "#5d4037"; // Trunk
            ctx.fillRect(this.x - 5, this.y, 10, this.radius);
            ctx.fillStyle = "#2e7d32"; // Leaves
            ctx.beginPath();
            ctx.arc(this.x, this.y - 10, this.radius * 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#388e3c"; // Lighter leaves
            ctx.beginPath();
            ctx.arc(this.x, this.y - 15, this.radius * 0.9, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.fillStyle = "#78909c"; // Rock base
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#90a4ae"; // Rock highlight
            ctx.beginPath();
            ctx.arc(
              this.x - this.radius * 0.2,
              this.y - this.radius * 0.2,
              this.radius * 0.6,
              0,
              Math.PI * 2,
            );
            ctx.fill();
          }
        }
      }

      class Enemy {
        constructor() {
          const spawnDist = Math.max(canvas.width, canvas.height) / 2 + 50;
          const angle = Math.random() * Math.PI * 2;
          this.x = player.x + Math.cos(angle) * spawnDist;
          this.y = player.y + Math.sin(angle) * spawnDist;

          this.radius = 12;
          // Scale difficulty slightly based on time
          const timeFactor = gameTime / 60;
          this.hp = 20 + timeFactor * 10;
          this.maxHp = this.hp;
          this.speed = 80 + Math.random() * 40;
          this.damage = 10;
          this.color = `hsl(${Math.random() * 60}, 80%, 50%)`; // Red/Orange/Yellow hues
        }

        update(dt) {
          const dirX = player.x - this.x;
          const dirY = player.y - this.y;
          const mag = Math.hypot(dirX, dirY);

          if (mag > 0) {
            this.x += (dirX / mag) * this.speed * dt;
            this.y += (dirY / mag) * this.speed * dt;
          }

          // Bounds
          this.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.x));
          this.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.y));

          // Obstacles
          obstacles.forEach((obs) => {
            const dx = this.x - obs.x;
            const dy = this.y - (obs.y + obs.radius * 0.5);
            const dist = Math.hypot(dx, dy);
            const minDist = this.radius + obs.radius * 0.6;
            if (dist < minDist && dist > 0) {
              this.x += (dx / dist) * (minDist - dist);
              this.y += (dy / dist) * (minDist - dist);
            }
          });
        }

        draw(ctx) {
          // Shadow
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y + this.radius * 0.8,
            this.radius,
            this.radius / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Slime Body
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(
            this.x,
            this.y,
            this.radius,
            Math.PI * 0.1,
            Math.PI * 0.9,
            true,
          );
          ctx.quadraticCurveTo(
            this.x,
            this.y + this.radius,
            this.x + Math.cos(Math.PI * 0.1) * this.radius,
            this.y + Math.sin(Math.PI * 0.1) * this.radius,
          );
          ctx.fill();

          // Inner glow
          ctx.fillStyle = "rgba(255,255,255,0.3)";
          ctx.beginPath();
          ctx.arc(
            this.x - this.radius * 0.3,
            this.y - this.radius * 0.4,
            this.radius * 0.3,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Angry Eyes
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.ellipse(this.x - 4, this.y - 2, 3, 4, -0.2, 0, Math.PI * 2);
          ctx.ellipse(this.x + 4, this.y - 2, 3, 4, 0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#f00"; // Red pupils
          ctx.beginPath();
          ctx.arc(this.x - 4, this.y - 2, 1.5, 0, Math.PI * 2);
          ctx.arc(this.x + 4, this.y - 2, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // ... (Player class remains mostly the same, add takeDamage method)
      // I will inject the entire modified script section to ensure correctness.
      class Player {
        constructor() {
          this.x = 0;
          this.y = 0;
          this.radius = 16;
          this.speed = 180;
          this.maxHp = 100;
          this.hp = 100;

          this.level = 1;
          this.exp = 0;
          this.expNeeded = 10;

          // Weapon Stats
          this.attackDamage = 10;
          this.attackCooldown = 0.5; // Seconds
          this.attackTimer = 0;
          this.attackRange = 250;
        }

        update(dt) {
          // Movement
          let vx = 0,
            vy = 0;

          if (keys["ArrowUp"] || keys["w"] || keys["W"]) vy -= 1;
          if (keys["ArrowDown"] || keys["s"] || keys["S"]) vy += 1;
          if (keys["ArrowLeft"] || keys["a"] || keys["A"]) vx -= 1;
          if (keys["ArrowRight"] || keys["d"] || keys["D"]) vx += 1;

          if (vx !== 0 || vy !== 0) {
            const mag = Math.hypot(vx, vy);
            vx /= mag;
            vy /= mag;
          } else if (joystick.active) {
            vx = joystick.dx;
            vy = joystick.dy;
          }

          this.x += vx * this.speed * dt;
          this.y += vy * this.speed * dt;

          // World Bounds
          this.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.x));
          this.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.y));

          // Obstacle collision
          obstacles.forEach((obs) => {
            const dx = this.x - obs.x;
            const dy = this.y - (obs.y + obs.radius * 0.5);
            const dist = Math.hypot(dx, dy);
            const minDist = this.radius + obs.radius * 0.6;
            if (dist < minDist && dist > 0) {
              const push = minDist - dist;
              this.x += (dx / dist) * push;
              this.y += (dy / dist) * push;
            }
          });

          // Auto Attack Logic
          this.attackTimer += dt;
          if (this.attackTimer >= this.attackCooldown) {
            this.fireProjectile();
          }
        }

        fireProjectile() {
          // To be overridden by subclasses
        }

        draw(ctx) {
          // Shadow shared by all
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y + this.radius,
            this.radius,
            this.radius / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
        }

        drawBaseHUD(ctx) {
          // HP Bar (Above player)
          const hpPct = Math.max(0, this.hp / this.maxHp);
          ctx.fillStyle = "#f00";
          ctx.fillRect(this.x - 15, this.y - 30, 30, 4);
          ctx.fillStyle = "#0f0";
          ctx.fillRect(this.x - 15, this.y - 30, 30 * hpPct, 4);

          // Level Text
          ctx.fillStyle = "#fff";
          ctx.font = "bold 12px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Lv." + this.level, this.x, this.y - 35);
        }
      }

      // --- MAGE CLASS ---
      class Mage extends Player {
        constructor() {
          super();
          this.speed = 120;
          this.maxHp = 100;
          this.hp = 100;
          this.attackDamage = 20;
          this.attackCooldown = 0.6;
          this.attackRange = 300;
        }

        fireProjectile() {
          if (enemies.length === 0) return;
          let closest = null;
          let minD = Infinity;
          for (let e of enemies) {
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            if (d < minD && d < this.attackRange) {
              minD = d;
              closest = e;
            }
          }

          if (closest) {
            this.attackTimer = 0;
            const dirX = closest.x - this.x;
            const dirY = closest.y - this.y;
            const mag = Math.hypot(dirX, dirY);
            projectiles.push({
              x: this.x,
              y: this.y,
              vx: (dirX / mag) * 400,
              vy: (dirY / mag) * 400,
              radius: 6,
              damage: this.attackDamage,
              life: 1.5,
              color: "#00e5ff",
              type: "orb",
            });
          }
        }

        draw(ctx) {
          super.draw(ctx);
          // Body (Robe)
          ctx.fillStyle = "#3f51b5"; // Indigo robe
          ctx.beginPath();
          ctx.arc(this.x, this.y + 4, 14, Math.PI, 0); // Shoulders
          ctx.lineTo(this.x + 12, this.y + 16);
          ctx.lineTo(this.x - 12, this.y + 16);
          ctx.closePath();
          ctx.fill();

          // Belt
          ctx.fillStyle = "#8d6e63";
          ctx.fillRect(this.x - 11, this.y + 8, 22, 4);
          ctx.fillStyle = "#ffeb3b";
          ctx.fillRect(this.x - 3, this.y + 7, 6, 6);

          // Head (Skin)
          ctx.fillStyle = "#ffccbc";
          ctx.beginPath();
          ctx.arc(this.x, this.y - 6, 12, 0, Math.PI * 2);
          ctx.fill();

          // Hair
          ctx.fillStyle = "#5d4037"; // Dark brown
          ctx.beginPath();
          ctx.arc(this.x, this.y - 8, 12.5, Math.PI, 0);
          ctx.lineTo(this.x + 14, this.y);
          ctx.lineTo(this.x + 8, this.y - 4);
          ctx.lineTo(this.x - 8, this.y - 4);
          ctx.lineTo(this.x - 14, this.y);
          ctx.closePath();
          ctx.fill();

          // Eyes
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.arc(this.x - 4, this.y - 5, 2.5, 0, Math.PI * 2);
          ctx.arc(this.x + 4, this.y - 5, 2.5, 0, Math.PI * 2);
          ctx.fill();
          // Eye Highlights
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(this.x - 4.5, this.y - 5.5, 1, 0, Math.PI * 2);
          ctx.arc(this.x + 3.5, this.y - 5.5, 1, 0, Math.PI * 2);
          ctx.fill();

          // Weapon (Magic Staff)
          ctx.fillStyle = "#795548"; // Wood
          ctx.fillRect(this.x + 10, this.y - 15, 4, 30);
          // Glowing Orb
          ctx.fillStyle = "#00e5ff"; // Cyan Gem
          ctx.shadowColor = "#00e5ff";
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(this.x + 12, this.y - 18, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0; // Reset
          // Inner orb highlight
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(this.x + 10.5, this.y - 19.5, 2, 0, Math.PI * 2);
          ctx.fill();

          this.drawBaseHUD(ctx);
        }
      }

      // --- KNIGHT CLASS ---
      class Knight extends Player {
        constructor() {
          super();
          this.speed = 100;
          this.maxHp = 180;
          this.hp = 180;
          this.attackDamage = 35;
          this.attackCooldown = 0.8;
          this.attackRange = 120; // Short melee range
          this.swingAngle = 0;
          this.isSwinging = false;
        }

        fireProjectile() {
          if (enemies.length === 0) return;
          let closest = null;
          let minD = Infinity;
          for (let e of enemies) {
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            if (d < minD && d < this.attackRange) {
              minD = d;
              closest = e;
            }
          }

          if (closest) {
            this.attackTimer = 0;
            this.isSwinging = true;
            this.swingAngle = Math.atan2(
              closest.y - this.y,
              closest.x - this.x,
            );

            // Melee splash: hit all enemies in a cone
            for (let i = enemies.length - 1; i >= 0; i--) {
              const e = enemies[i];
              const d = Math.hypot(this.x - e.x, this.y - e.y);
              if (d <= this.attackRange) {
                const angleToEnemy = Math.atan2(e.y - this.y, e.x - this.x);
                let angleDiff = angleToEnemy - this.swingAngle;
                // Normalize angle to -PI to PI
                angleDiff = Math.atan2(
                  Math.sin(angleDiff),
                  Math.cos(angleDiff),
                );
                if (Math.abs(angleDiff) < Math.PI / 3) {
                  // 120 degree cone
                  e.hp -= this.attackDamage;
                  damageNumbers.push({
                    x: e.x + (Math.random() - 0.5) * 20,
                    y: e.y - 10,
                    val: this.attackDamage,
                    life: 0.8,
                    vy: -30,
                  });
                  // Knockback
                  e.x += Math.cos(angleToEnemy) * 20;
                  e.y += Math.sin(angleToEnemy) * 20;

                  if (e.hp <= 0) {
                    const rand = Math.random();
                    if (rand < 0.05) {
                      const types = ["hp", "bomb", "magnet"];
                      items.push({
                        x: e.x,
                        y: e.y,
                        radius: 10,
                        type: types[Math.floor(Math.random() * types.length)],
                      });
                    } else if (rand < 0.1) {
                      items.push({ x: e.x, y: e.y, radius: 10, type: "coin" });
                    } else {
                      gems.push({ x: e.x, y: e.y, radius: 4, exp: 5 });
                    }
                    enemies.splice(i, 1);
                  }
                }
              }
            }
            setTimeout(() => (this.isSwinging = false), 200);
          }
        }

        draw(ctx) {
          super.draw(ctx);

          // Melee Swing Arc
          if (this.isSwinging) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.arc(
              this.x,
              this.y,
              this.attackRange,
              this.swingAngle - Math.PI / 3,
              this.swingAngle + Math.PI / 3,
            );
            ctx.fill();
            // Sword visual swing
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(
              this.x + Math.cos(this.swingAngle) * this.attackRange * 0.8,
              this.y + Math.sin(this.swingAngle) * this.attackRange * 0.8,
            );
            ctx.stroke();
          }

          // Body (Armor)
          ctx.fillStyle = "#9e9e9e"; // Steel armor
          ctx.beginPath();
          ctx.arc(this.x, this.y + 4, 15, Math.PI, 0);
          ctx.lineTo(this.x + 13, this.y + 16);
          ctx.lineTo(this.x - 13, this.y + 16);
          ctx.closePath();
          ctx.fill();

          // Helmet
          ctx.fillStyle = "#e0e0e0";
          ctx.beginPath();
          ctx.arc(this.x, this.y - 6, 13, 0, Math.PI * 2);
          ctx.fill();

          // Visor slit
          ctx.fillStyle = "#212121";
          ctx.fillRect(this.x - 8, this.y - 8, 16, 4);

          // Shield
          if (!this.isSwinging) {
            ctx.fillStyle = "#b71c1c"; // Red shield
            ctx.beginPath();
            ctx.arc(this.x - 12, this.y + 5, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffeb3b";
            ctx.beginPath();
            ctx.arc(this.x - 12, this.y + 5, 4, 0, Math.PI * 2);
            ctx.fill();

            // Sword Rest
            ctx.strokeStyle = "#e0e0e0";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(this.x + 12, this.y + 10);
            ctx.lineTo(this.x + 15, this.y - 15);
            ctx.stroke();
          }

          this.drawBaseHUD(ctx);
        }
      }

      // --- RANGER CLASS ---
      class Ranger extends Player {
        constructor() {
          super();
          this.speed = 160;
          this.maxHp = 80;
          this.hp = 80;
          this.attackDamage = 8;
          this.attackCooldown = 0.25; // Very fast
          this.attackRange = 400; // Long range
        }

        fireProjectile() {
          if (enemies.length === 0) return;
          let closest = null;
          let minD = Infinity;
          for (let e of enemies) {
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            if (d < minD && d < this.attackRange) {
              minD = d;
              closest = e;
            }
          }

          if (closest) {
            this.attackTimer = 0;
            const dirX = closest.x - this.x;
            const dirY = closest.y - this.y;
            const mag = Math.hypot(dirX, dirY);

            // Arrow logic
            projectiles.push({
              x: this.x,
              y: this.y,
              vx: (dirX / mag) * 600, // Fast arrow
              vy: (dirY / mag) * 600,
              radius: 4,
              damage: this.attackDamage,
              life: 1.0,
              color: "#e6ee9c", // Yellowish arrow
              type: "arrow",
              angle: Math.atan2(dirY, dirX),
            });
          }
        }

        draw(ctx) {
          super.draw(ctx);
          // Body (Tunic)
          ctx.fillStyle = "#2e7d32"; // Green tunic
          ctx.beginPath();
          ctx.arc(this.x, this.y + 4, 13, Math.PI, 0);
          ctx.lineTo(this.x + 11, this.y + 15);
          ctx.lineTo(this.x - 11, this.y + 15);
          ctx.closePath();
          ctx.fill();

          // Belt / Quiver strap
          ctx.strokeStyle = "#5d4037";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.x - 10, this.y - 2);
          ctx.lineTo(this.x + 10, this.y + 12);
          ctx.stroke();

          // Head (Skin)
          ctx.fillStyle = "#ffccbc";
          ctx.beginPath();
          ctx.arc(this.x, this.y - 6, 11, 0, Math.PI * 2);
          ctx.fill();

          // Hood
          ctx.fillStyle = "#1b5e20"; // Dark green hood
          ctx.beginPath();
          ctx.arc(this.x, this.y - 8, 12, Math.PI * 1.1, Math.PI * -0.1);
          ctx.fill();

          // Eyes
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.arc(this.x - 4, this.y - 5, 2, 0, Math.PI * 2);
          ctx.arc(this.x + 4, this.y - 5, 2, 0, Math.PI * 2);
          ctx.fill();

          // Bow
          ctx.strokeStyle = "#8d6e63"; // Bow wood
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x + 12, this.y + 2, 12, Math.PI * -0.3, Math.PI * 0.3);
          ctx.stroke();
          // Bow string
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(this.x + 19, this.y - 7);
          ctx.lineTo(this.x + 19, this.y + 11);
          ctx.stroke();

          this.drawBaseHUD(ctx);
        }
      }

      // --- Core Functions ---
      function resize() {
        // height approx 90% of window height, but don't exceed 95% of window width
        let size = window.innerHeight * 0.9;
        if (size > window.innerWidth * 0.95) {
          size = window.innerWidth * 0.95;
        }

        const container = document.getElementById("gameContainer");
        if (container) {
          container.style.width = size + "px";
          container.style.height = size + "px";
        }

        canvas.width = size;
        canvas.height = size;
      }
      window.addEventListener("resize", resize);
      resize();

      function updateUI() {
        const mins = Math.floor(gameTime / 60)
          .toString()
          .padStart(2, "0");
        const secs = Math.floor(gameTime % 60)
          .toString()
          .padStart(2, "0");
        document.getElementById("timeText").innerText = `${mins}:${secs}`;

        const expPct = (player.exp / player.expNeeded) * 100;
        document.getElementById("expBar").style.width = `${expPct}%`;
        document.getElementById("levelText").innerText = player.level;
        document.getElementById("hpText").innerText =
          `${Math.ceil(player.hp)}/${player.maxHp}`;
      }

      function startGame() {
        document.getElementById("titleScreen").classList.remove("active");
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("hud").style.display = "flex";

        if ("ontouchstart" in window) {
          document.getElementById("joystick-zone").style.display = "block";
        }

        player = new Player();
        enemies = [];
        gems = [];
        items = [];
        projectiles = [];
        damageNumbers = [];
        obstacles = [];

        // Generate random obstacles
        for (let i = 0; i < 40; i++) {
          obstacles.push(new Obstacle());
        }

        gameTime = 0;
        gameState = "playing";
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
      }

      function exitGame() {
        gameState = "title";
        document.getElementById("hud").style.display = "none";
        document.getElementById("joystick-zone").style.display = "none";
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("levelUpScreen").classList.remove("active");
        document.getElementById("titleScreen").classList.add("active");
      }

      // Utility Collision
      function circleIntersect(x1, y1, r1, x2, y2, r2) {
        return Math.hypot(x1 - x2, y1 - y2) < r1 + r2;
      }

      function drawGrid() {
        const gridSize = 40;
        const offsetX = -(camera.x % gridSize);
        const offsetY = -(camera.y % gridSize);

        ctx.strokeStyle = "rgba(0, 0, 0, 0.1)"; // Very subtle dark lines
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = offsetX; x < canvas.width; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
        }
        for (let y = offsetY; y < canvas.height; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
      }

      function gameLoop(time) {
        if (gameState !== "playing") return;

        const dt = (time - lastTime) / 1000;
        lastTime = time;
        const safeDt = Math.min(dt, 0.1);

        gameTime += safeDt;

        // --- 1. UPDATE --- //
        player.update(safeDt);

        // Enemy Spawning
        // Spawn rate increases over time
        const spawnChance = 0.02 + (gameTime / 60) * 0.05;
        // Maximum number of enemies allowed safely on screen (150 cap)
        if (enemies.length < 150 && Math.random() < spawnChance) {
          enemies.push(new Enemy());
        }

        // Update Enemies
        enemies.forEach((e) => e.update(safeDt));

        // Update Projectiles & Collisions
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          p.x += p.vx * safeDt;
          p.y += p.vy * safeDt;
          p.life -= safeDt;

          let hit = false;
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (circleIntersect(p.x, p.y, p.radius, e.x, e.y, e.radius)) {
              e.hp -= p.damage;
              hit = true;

              // Damage number
              damageNumbers.push({
                x: e.x + (Math.random() - 0.5) * 20,
                y: e.y - 10,
                val: p.damage,
                life: 0.8,
                vy: -30,
              });

              if (e.hp <= 0) {
                // Drop Coin, Gem or Special Item
                const rand = Math.random();
                if (rand < 0.05) {
                  // 5% chance for special item
                  const types = ["hp", "bomb", "magnet"];
                  items.push({
                    x: e.x,
                    y: e.y,
                    radius: 10,
                    type: types[Math.floor(Math.random() * types.length)],
                  });
                } else if (rand < 0.1) {
                  // 5% chance for Baht Coin (0.05 to 0.10)
                  items.push({
                    x: e.x,
                    y: e.y,
                    radius: 10,
                    type: "coin",
                  });
                } else {
                  gems.push({
                    x: e.x,
                    y: e.y,
                    radius: 4,
                    exp: 5,
                  });
                }
                enemies.splice(j, 1);
              }
              break;
            }
          }
          if (hit || p.life <= 0) {
            projectiles.splice(i, 1);
          }
        }

        // Update Player Magnet Timer
        if (player.magnetTimer === undefined) player.magnetTimer = 0;
        if (player.magnetTimer > 0) player.magnetTimer -= safeDt;

        // Player collecting gems
        for (let i = gems.length - 1; i >= 0; i--) {
          const g = gems[i];
          // Simple magnetic effect when close
          const dist = Math.hypot(player.x - g.x, player.y - g.y);
          const pullDist = player.magnetTimer > 0 ? 240 : 80;
          const pullSpeed = player.magnetTimer > 0 ? 600 : 250;

          if (dist < pullDist && dist > 0) {
            g.x += ((player.x - g.x) / dist) * pullSpeed * safeDt;
            g.y += ((player.y - g.y) / dist) * pullSpeed * safeDt;
          }
          if (dist < player.radius + g.radius + 5) {
            player.exp += g.exp;
            gems.splice(i, 1);
            // Level up check
            if (player.exp >= player.expNeeded) {
              player.level++;
              player.exp -= player.expNeeded;
              player.expNeeded = Math.floor(player.expNeeded * 1.5);

              triggerLevelUp();
            }
          }
        }

        // Player collecting Special Items
        for (let i = items.length - 1; i >= 0; i--) {
          const item = items[i];
          const dist = Math.hypot(player.x - item.x, player.y - item.y);

          if (dist < player.radius + item.radius + 5) {
            if (item.type === "hp") {
              const heal = player.maxHp * 0.3;
              player.hp = Math.min(player.maxHp, player.hp + heal);
              damageNumbers.push({
                x: player.x,
                y: player.y - 20,
                val: "+HP",
                life: 1,
                vy: -40,
              });
            } else if (item.type === "bomb") {
              // Destroy enemies within magnet radius (240)
              const bombRadius = 240;
              for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                const d = Math.hypot(player.x - e.x, player.y - e.y);
                if (d <= bombRadius) {
                  gems.push({ x: e.x, y: e.y, radius: 4, exp: 5 });
                  damageNumbers.push({
                    x: e.x,
                    y: e.y - 10,
                    val: "BOOM",
                    life: 0.8,
                    vy: -30,
                  });
                  enemies.splice(j, 1);
                }
              }
            } else if (item.type === "magnet") {
              player.magnetTimer = 3; // Activate magnet for 3 seconds
            } else if (item.type === "coin") {
              khunoSessionCoins++;
              damageNumbers.push({
                x: player.x,
                y: player.y - 20,
                val: "+1 K",
                life: 1,
                vy: -40,
              });
            }
            items.splice(i, 1);
          }
        }

        // Enemies hitting player
        enemies.forEach((e) => {
          if (
            circleIntersect(
              player.x,
              player.y,
              player.radius,
              e.x,
              e.y,
              e.radius,
            )
          ) {
            // Simple invincibility frames could be added, for now just constant drain
            player.hp -= e.damage * safeDt;
            if (player.hp <= 0 && gameState !== "gameover") {
              gameState = "gameover";
              triggerGameOver();
            }
          }
        });

        // Update Damage Numbers
        damageNumbers.forEach((d) => {
          d.y += d.vy * safeDt;
          d.life -= safeDt;
        });
        damageNumbers = damageNumbers.filter((d) => d.life > 0);

        // Camera smoothly follow player
        camera.x += (player.x - canvas.width / 2 - camera.x) * 5 * safeDt;
        camera.y += (player.y - canvas.height / 2 - camera.y) * 5 * safeDt;

        // --- 2. DRAW --- //
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background
        ctx.fillStyle = "#436b4a"; // Soft grass green
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw World Bounds
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.lineWidth = 10;
        ctx.strokeRect(
          -WORLD_SIZE / 2,
          -WORLD_SIZE / 2,
          WORLD_SIZE,
          WORLD_SIZE,
        );

        // Draw Obstacles
        // Sort with enemies for Y-depth
        let renderables = [...obstacles, ...enemies];
        renderables.sort((a, b) => a.y - b.y);

        // Draw Gems (under entities)
        gems.forEach((g) => {
          ctx.fillStyle = "#00f2fe"; // Blue EXP gem
          ctx.beginPath();
          ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        // Draw Special Items
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        items.forEach((item) => {
          let icon = "";
          if (item.type === "hp") icon = "‚ù§Ô∏è";
          else if (item.type === "bomb") icon = "üí£";
          else if (item.type === "magnet") icon = "üß≤";
          else if (item.type === "coin") icon = "üí∞";

          // Outer glow for visibility
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 10;
          ctx.fillText(icon, item.x, item.y);
          ctx.shadowBlur = 0;
        });

        // Draw Enemies & Obstacles (sorted)
        renderables.forEach((r) => r.draw(ctx));

        // Draw Projectiles
        projectiles.forEach((p) => {
          if (p.type === "arrow") {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            // Draw an arrow shape
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.moveTo(8, 0); // Tip
            ctx.lineTo(-6, -4);
            ctx.lineTo(-6, 4);
            ctx.closePath();
            ctx.fill();
            // Arrow shaft
            ctx.strokeStyle = "#8d6e63";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.lineTo(8, 0);
            ctx.stroke();
            ctx.restore();
          } else {
            // Default orb (Mage)
            ctx.fillStyle = p.color || "#00e5ff";
            ctx.shadowColor = p.color || "#00e5ff";
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0; // reset
          }
        });

        // Draw Player
        player.draw(ctx);

        // Draw Damage Numbers
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 14px Outfit, sans-serif";
        damageNumbers.forEach((d) => {
          ctx.globalAlpha = Math.max(0, d.life / 0.8);
          ctx.fillStyle = "#fff";
          ctx.fillText(d.val, d.x, d.y);
          ctx.globalAlpha = 1;
        });

        ctx.restore();

        updateUI();

        if (gameState === "playing") {
          requestAnimationFrame(gameLoop);
        }
      }

      // --- Game Flow & UI Functions ---
      function triggerLevelUp() {
        gameState = "levelup";
        document.getElementById("levelUpScreen").classList.add("active");

        const optionsDiv = document.getElementById("upgradeOptions");
        optionsDiv.innerHTML = "";

        // Give a bit of Baht logic if they have max level or want a refund option? (Optional, skipping for now)

        const upgrades = [
          {
            name: "üí™ Damage Up",
            desc: "+5 Attack Damage",
            apply: () => (player.attackDamage += 5),
          },
          {
            name: "‚ö° Attack Speed",
            desc: "-0.05s Cooldown",
            apply: () =>
              (player.attackCooldown = Math.max(
                0.1,
                player.attackCooldown - 0.05,
              )),
          },
          {
            name: "‚ù§Ô∏è Max HP",
            desc: "+20 Max HP & Heal",
            apply: () => {
              player.maxHp += 20;
              player.hp += 20;
            },
          },
          {
            name: "üèÉ Speed Up",
            desc: "+20 Movement Speed",
            apply: () => (player.speed += 20),
          },
          {
            name: "üèπ Range Up",
            desc: "+50 Attack Range",
            apply: () => (player.attackRange += 50),
          },
        ];

        // Pick 3 random
        const shuffled = upgrades.sort(() => 0.5 - Math.random());
        const selected = shuffled.slice(0, 3);

        selected.forEach((upg) => {
          const btn = document.createElement("button");
          btn.className = "btn-main";
          btn.style.fontSize = "1.2rem";
          btn.style.padding = "10px";
          btn.innerHTML = `<strong>${upg.name}</strong><br><span style="font-size:0.9rem; font-weight:normal;">${upg.desc}</span>`;
          btn.onclick = () => {
            upg.apply();
            document.getElementById("levelUpScreen").classList.remove("active");
            gameState = "playing";
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
          };
          optionsDiv.appendChild(btn);
        });
      }
      function triggerGameOver() {
        document.getElementById("gameOverScreen").classList.add("active");
        document.getElementById("hud").style.display = "none";
        document.getElementById("joystick-zone").style.display = "none";

        // Add run money to total money
        globalKhuno += khunoSessionCoins;
        localStorage.setItem("khunoCoins", globalKhuno);
        document.getElementById("titleTotalKhuno").innerText = globalKhuno;
        document.getElementById("charSelectKhuno").innerText = globalKhuno;

        let goKhunoEl = document.getElementById("goKhunoEarned");
        if (goKhunoEl) {
          goKhunoEl.innerText = `üí∞ + ${khunoSessionCoins} K`;
          goKhunoEl.style.display = "block";
        }

        const mins = Math.floor(gameTime / 60)
          .toString()
          .padStart(2, "0");
        const secs = Math.floor(gameTime % 60)
          .toString()
          .padStart(2, "0");
        document.getElementById("finalTime").innerText = `${mins}:${secs}`;
        document.getElementById("finalLevel").innerText = player.level;

        updateHighScores(Math.floor(gameTime), player.level);
      }

      function updateUI() {
        document.getElementById("timeText").innerText =
          Math.floor(gameTime / 60)
            .toString()
            .padStart(2, "0") +
          ":" +
          Math.floor(gameTime % 60)
            .toString()
            .padStart(2, "0");

        document.getElementById("hpText").innerText =
          Math.floor(player.hp) + "/" + player.maxHp;

        document.getElementById("levelText").innerText = player.level;
        document.getElementById("expBar").style.width =
          (player.exp / player.expNeeded) * 100 + "%";

        document.getElementById("hudKhuno").innerText = khunoSessionCoins;
      }

      function exitGame() {
        // Save current coins
        globalKhuno += khunoSessionCoins;
        localStorage.setItem("khunoCoins", globalKhuno);
        document.getElementById("titleTotalKhuno").innerText = globalKhuno;

        gameState = "title";
        document.getElementById("hud").style.display = "none";
        document.getElementById("joystick-zone").style.display = "none";
        document.getElementById("titleScreen").classList.add("active");
        if (player) {
          updateHighScores(Math.floor(gameTime), player.level);
        }
      }

      function showCharSelect() {
        document.getElementById("titleScreen").classList.remove("active");
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("charSelectScreen").classList.add("active");

        document.getElementById("charSelectKhuno").innerText = globalKhuno;

        // Update buttons based on ownership
        if (ownedChars.includes("knight")) {
          document.getElementById("btn-buy-knight").style.display = "none";
          document.getElementById("btn-play-knight").style.display = "block";
        } else {
          document.getElementById("btn-buy-knight").style.display = "block";
          document.getElementById("btn-play-knight").style.display = "none";
        }

        if (ownedChars.includes("ranger")) {
          document.getElementById("btn-buy-ranger").style.display = "none";
          document.getElementById("btn-play-ranger").style.display = "block";
        } else {
          document.getElementById("btn-buy-ranger").style.display = "block";
          document.getElementById("btn-play-ranger").style.display = "none";
        }
      }

      function buyChar(charId, price) {
        if (globalKhuno >= price) {
          globalKhuno -= price;
          ownedChars.push(charId);
          localStorage.setItem("khunoCoins", globalKhuno);
          localStorage.setItem(
            "pixelSurvivorOwnedChars",
            JSON.stringify(ownedChars),
          );
          document.getElementById("titleTotalKhuno").innerText = globalKhuno;
          showCharSelect(); // Refresh UI
        } else {
          alert("Not enough Khuno! üí∞");
        }
      }

      function startGame(charType = "mage") {
        document.getElementById("charSelectScreen").classList.remove("active");
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("titleScreen").classList.remove("active");

        document.getElementById("hud").style.display = "flex";

        if ("ontouchstart" in window) {
          document.getElementById("joystick-zone").style.display = "block";
        }

        if (charType === "knight") player = new Knight();
        else if (charType === "ranger") player = new Ranger();
        else player = new Mage();

        enemies = [];
        gems = [];
        items = [];
        projectiles = [];
        damageNumbers = [];
        obstacles = [];
        khunoSessionCoins = 0; // Reset run multiplier
        document.getElementById("hudKhuno").innerText = "0";

        // Generate random obstacles
        for (let i = 0; i < 40; i++) {
          obstacles.push(new Obstacle());
        }

        gameTime = 0;
        gameState = "playing";
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
      }

      function updateHighScores(currentTime, currentLevel) {
        let bestTime = parseInt(
          localStorage.getItem("pixelSurvivorBestTime") || 0,
        );
        let bestLevel = parseInt(
          localStorage.getItem("pixelSurvivorBestLevel") || 1,
        );

        if (currentTime > bestTime) {
          bestTime = currentTime;
          localStorage.setItem("pixelSurvivorBestTime", bestTime);
        }
        if (currentLevel > bestLevel) {
          bestLevel = currentLevel;
          localStorage.setItem("pixelSurvivorBestLevel", bestLevel);
        }

        const bMins = Math.floor(bestTime / 60)
          .toString()
          .padStart(2, "0");
        const bSecs = Math.floor(bestTime % 60)
          .toString()
          .padStart(2, "0");

        document.getElementById("titleBestTime").innerText =
          `${bMins}:${bSecs}`;
        document.getElementById("titleBestLevel").innerText = bestLevel;
        if (document.getElementById("goBestTime")) {
          document.getElementById("goBestTime").innerText = `${bMins}:${bSecs}`;
          document.getElementById("goBestLevel").innerText = bestLevel;
        }
      }

      function toggleModal(id, show) {
        if (show) {
          document.getElementById(id).classList.add("active");
        } else {
          document.getElementById(id).classList.remove("active");
        }
      }

      // --- Input Listeners ---
      window.addEventListener("keydown", (e) => (keys[e.key] = true));
      window.addEventListener("keyup", (e) => (keys[e.key] = false));

      const jZone = document.getElementById("joystick-zone");
      const jKnob = document.getElementById("joystick-knob");

      function resetJoystick() {
        joystick.active = false;
        joystick.dx = 0;
        joystick.dy = 0;
        jKnob.style.transform = `translate(0px, 0px)`;
      }

      jZone.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        const rect = jZone.getBoundingClientRect();
        joystick.baseX = rect.left + rect.width / 2;
        joystick.baseY = rect.top + rect.height / 2;
        joystick.active = true;
        handleTouch(touch);
      });

      jZone.addEventListener(
        "touchmove",
        (e) => {
          if (!joystick.active) return;
          e.preventDefault();
          handleTouch(e.touches[0]);
        },
        { passive: false },
      );

      jZone.addEventListener("touchend", resetJoystick);
      jZone.addEventListener("touchcancel", resetJoystick);

      function handleTouch(touch) {
        let dx = touch.clientX - joystick.baseX;
        let dy = touch.clientY - joystick.baseY;
        const dist = Math.hypot(dx, dy);
        const maxDist = 50;

        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }

        jKnob.style.transform = `translate(${dx}px, ${dy}px)`;
        joystick.dx = dx / maxDist;
        joystick.dy = dy / maxDist;
      }

      // Init logic
      updateHighScores(0, 1);
    </script>
  </body>
</html>
