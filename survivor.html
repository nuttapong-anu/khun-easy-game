<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>Pixel Survivor</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      body {
        font-family: "Outfit", sans-serif;
        background: #111;
        color: #fff;
        overflow: hidden;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }
      #gameContainer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        overflow: hidden;
        border: 4px solid #fff;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
      }
      #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #436b4a; /* Soft grass green */
        image-rendering: pixelated;
      }

      /* UI Overlays */
      .screen {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(5px);
      }
      .screen.active {
        display: flex;
      }

      h1 {
        font-size: 3rem;
        color: #ffab40;
        text-shadow: 0 4px 10px rgba(255, 171, 64, 0.5);
        margin-bottom: 20px;
        text-align: center;
      }

      .btn-main {
        background: linear-gradient(135deg, #ffab40, #ff6d00);
        border: none;
        padding: 15px 40px;
        font-size: 1.5rem;
        font-weight: 800;
        color: #fff;
        border-radius: 30px;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(255, 109, 0, 0.4);
        transition: all 0.2s;
        font-family: inherit;
        text-transform: uppercase;
      }
      .btn-main:hover {
        transform: scale(1.05);
      }

      /* HUD */
      #hud {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 10px;
        z-index: 50;
        pointer-events: none;
        display: none;
        flex-direction: column;
        gap: 10px;
      }
      .hud-top {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .timer {
        font-size: 1.5rem;
        font-weight: bold;
        color: #fff;
        text-shadow: 1px 1px 3px #000;
      }

      /* EXP Bar */
      .exp-container {
        width: 100%;
        height: 12px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 6px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
        position: relative;
      }
      .exp-bar {
        height: 100%;
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        width: 0%;
        transition: width 0.2s;
      }
      .level-text {
        position: absolute;
        top: -20px;
        right: 0;
        font-size: 0.9rem;
        font-weight: bold;
        color: #4facfe;
        text-shadow: 1px 1px 2px #000;
      }

      /* Health Bar Overlay (Above player) */
      /* Drawn in canvas relative to player pos */

      /* Buttons & Joysticks */
      .home-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        text-decoration: none;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 15px;
        border-radius: 20px;
        font-weight: bold;
        color: #fff;
        z-index: 200;
        transition: all 0.2s;
        font-size: 0.9rem;
        pointer-events: auto;
      }

      /* Virtual Joystick */
      #joystick-zone {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 150px;
        height: 150px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        z-index: 80;
        display: none; /* Only show on touch / gameplay */
        pointer-events: auto;
      }
      #joystick-knob {
        position: absolute;
        top: 50px;
        left: 50px;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <!-- Title Screen -->
    <div id="titleScreen" class="screen active">
      <a href="index.html" class="home-btn">üè† Home</a>
      <h1>‚öîÔ∏è Pixel Survivor</h1>
      <div
        style="
          color: #ffccbc;
          margin-bottom: 20px;
          font-size: 1.1rem;
          text-shadow: 1px 1px 3px #000;
        "
      >
        üèÜ Best Time: <span id="titleBestTime">00:00</span> | üåü Max Lv:
        <span id="titleBestLevel">1</span>
      </div>
      <button class="btn-main" onclick="startGame()">‚ñ∂ Play</button>
      <button
        class="home-btn"
        style="
          position: relative;
          top: auto;
          left: auto;
          margin-top: 20px;
          background: rgba(255, 255, 255, 0.2);
        "
        onclick="toggleModal('howToModal', true)"
      >
        ‚ùì ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô
      </button>
    </div>

    <!-- How to Play Modal -->
    <div id="howToModal" class="screen">
      <div
        style="
          background: #fff;
          color: #333;
          padding: 20px;
          border-radius: 15px;
          max-width: 90%;
          min-width: 300px;
          position: relative;
        "
      >
        <h2 style="margin-bottom: 15px; text-align: center; color: #ff6d00">
          ‚öîÔ∏è ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô Pixel Survivor
        </h2>
        <ul style="line-height: 1.6; margin-left: 20px; margin-bottom: 15px">
          <li>
            ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏î‡πâ‡∏ß‡∏¢ <strong>‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏π‡∏Å‡∏®‡∏£ (W,A,S,D)</strong> ‡∏´‡∏£‡∏∑‡∏≠
            <strong>‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å‡∏à‡∏≥‡∏•‡∏≠‡∏á</strong> ‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
          </li>
          <li>‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏à‡∏∞ <strong>‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÉ‡∏Å‡∏•‡πâ‡∏™‡∏∏‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</strong></li>
          <li>
            ‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡πâ‡∏ß
            <strong>‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡∏±‡∏•‡∏™‡∏µ‡∏ü‡πâ‡∏≤ (EXP)</strong> ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏•‡πÄ‡∏ß‡∏•
          </li>
          <li>
            üéÅ <strong>‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏û‡∏¥‡πÄ‡∏®‡∏©</strong>: ‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏°‡∏µ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏£‡∏≠‡∏õ ‚ù§Ô∏è (‡∏Æ‡∏µ‡∏•), üí£
            (‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏à‡∏≠), ‡∏´‡∏£‡∏∑‡∏≠ üß≤ (‡∏î‡∏π‡∏î‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡∏±‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)
          </li>
          <li>
            ‚ö†Ô∏è <strong>‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ</strong>:
            ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÅ‡∏•‡∏∞‡∏´‡∏¥‡∏ô‡∏à‡∏∞‡∏Ç‡∏ß‡∏≤‡∏á‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡∏∞‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå
          </li>
          <li>
            ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏≠‡∏±‡∏õ ‡∏à‡∏∞‡∏°‡∏µ
            <strong>‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î 3 ‡∏≠‡∏¢‡πà‡∏≤‡∏á</strong>
            ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á
          </li>
          <li>‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏∑‡∏≠: <strong>‡πÄ‡∏≠‡∏≤‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏£‡∏≠‡∏î‡πÉ‡∏´‡πâ‡∏ô‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î!</strong></li>
          <li>
            üö™ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°
            <strong>Exit</strong> ‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏±‡∏ô‡πÑ‡∏î‡πâ
          </li>
        </ul>
        <div style="text-align: center">
          <button
            class="btn-main"
            style="padding: 10px 20px; font-size: 1rem"
            onclick="toggleModal('howToModal', false)"
          >
            ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏•‡πâ‡∏ß!
          </button>
        </div>
      </div>
    </div>

    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <!-- Gameplay HUD -->
      <div id="hud">
        <div class="exp-container">
          <div class="level-text">Lv.<span id="levelText">1</span></div>
          <div class="exp-bar" id="expBar"></div>
        </div>
        <div class="hud-top">
          <div style="display: flex; gap: 15px; align-items: center">
            <div class="timer" id="timeText" style="min-width: 70px">00:00</div>
            <div
              style="
                background: rgba(0, 0, 0, 0.5);
                padding: 5px 10px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.2);
              "
            >
              <span style="color: #ff5252; font-weight: bold">‚ù§</span>
              <span id="hpText" style="font-weight: bold">100/100</span>
            </div>
          </div>
          <button
            class="home-btn"
            style="
              position: relative;
              top: 0;
              left: 0;
              background: rgba(244, 67, 54, 0.8);
              border: none;
              cursor: pointer;
            "
            onclick="exitGame()"
          >
            üö™ Exit
          </button>
        </div>
      </div>

      <div id="joystick-zone">
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- Level Up Screen -->
    <div id="levelUpScreen" class="screen">
      <h2 style="font-size: 2rem; color: #4facfe; margin-bottom: 20px">
        üéâ LEVEL UP!
      </h2>
      <div
        id="upgradeOptions"
        style="
          display: flex;
          flex-direction: column;
          gap: 15px;
          width: 80%;
          max-width: 400px;
        "
      >
        <!-- Populated via JS -->
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen">
      <h2 style="font-size: 3rem; color: #f44336; margin-bottom: 10px">
        GAME OVER
      </h2>
      <p style="font-size: 1.2rem; margin-bottom: 20px">
        Survived for: <span id="finalTime">00:00</span>
      </p>
      <p style="font-size: 1.2rem; margin-bottom: 20px">
        Reached Level: <span id="finalLevel">1</span>
      </p>
      <div
        style="
          color: #ffccbc;
          margin-bottom: 30px;
          font-size: 1.1rem;
          text-shadow: 1px 1px 3px #000;
        "
      >
        üèÜ Best Time: <span id="goBestTime">00:00</span> | üåü Max Lv:
        <span id="goBestLevel">1</span>
      </div>
      <button class="btn-main" onclick="startGame()">üîÑ Play Again</button>
      <a
        href="index.html"
        class="home-btn"
        style="position: relative; top: auto; left: auto; margin-top: 15px"
        >üè† Home</a
      >
    </div>

    <script>
      // --- Game Constants & State ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let gameState = "title"; // title, playing, levelup, gameover
      let lastTime = 0;
      let gameTime = 0;

      // Virtual Camera
      let camera = { x: 0, y: 0 };

      // Inputs
      let keys = {};
      let joystick = { active: false, dx: 0, dy: 0, baseX: 0, baseY: 0 };

      // Entities
      let player;
      let enemies = [];
      let gems = [];
      let items = []; // Special items
      let projectiles = [];
      let damageNumbers = [];
      let obstacles = [];
      const WORLD_SIZE = 2000;

      // --- Classes ---
      class Obstacle {
        constructor() {
          this.x = (Math.random() - 0.5) * WORLD_SIZE;
          this.y = (Math.random() - 0.5) * WORLD_SIZE;
          this.radius = 20 + Math.random() * 20;
          this.type = Math.random() > 0.5 ? "tree" : "rock";
        }
        draw(ctx) {
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y + this.radius * 0.8,
            this.radius,
            this.radius / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          if (this.type === "tree") {
            ctx.fillStyle = "#5d4037"; // Trunk
            ctx.fillRect(this.x - 5, this.y, 10, this.radius);
            ctx.fillStyle = "#2e7d32"; // Leaves
            ctx.beginPath();
            ctx.arc(this.x, this.y - 10, this.radius * 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#388e3c"; // Lighter leaves
            ctx.beginPath();
            ctx.arc(this.x, this.y - 15, this.radius * 0.9, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.fillStyle = "#78909c"; // Rock base
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#90a4ae"; // Rock highlight
            ctx.beginPath();
            ctx.arc(
              this.x - this.radius * 0.2,
              this.y - this.radius * 0.2,
              this.radius * 0.6,
              0,
              Math.PI * 2,
            );
            ctx.fill();
          }
        }
      }

      class Enemy {
        constructor() {
          const spawnDist = Math.max(canvas.width, canvas.height) / 2 + 50;
          const angle = Math.random() * Math.PI * 2;
          this.x = player.x + Math.cos(angle) * spawnDist;
          this.y = player.y + Math.sin(angle) * spawnDist;

          this.radius = 12;
          // Scale difficulty slightly based on time
          const timeFactor = gameTime / 60;
          this.hp = 20 + timeFactor * 10;
          this.maxHp = this.hp;
          this.speed = 80 + Math.random() * 40;
          this.damage = 10;
          this.color = `hsl(${Math.random() * 60}, 80%, 50%)`; // Red/Orange/Yellow hues
        }

        update(dt) {
          const dirX = player.x - this.x;
          const dirY = player.y - this.y;
          const mag = Math.hypot(dirX, dirY);

          if (mag > 0) {
            this.x += (dirX / mag) * this.speed * dt;
            this.y += (dirY / mag) * this.speed * dt;
          }

          // Bounds
          this.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.x));
          this.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.y));

          // Obstacles
          obstacles.forEach((obs) => {
            const dx = this.x - obs.x;
            const dy = this.y - (obs.y + obs.radius * 0.5);
            const dist = Math.hypot(dx, dy);
            const minDist = this.radius + obs.radius * 0.6;
            if (dist < minDist && dist > 0) {
              this.x += (dx / dist) * (minDist - dist);
              this.y += (dy / dist) * (minDist - dist);
            }
          });
        }

        draw(ctx) {
          // Shadow
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y + this.radius * 0.8,
            this.radius,
            this.radius / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Slime Body
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(
            this.x,
            this.y,
            this.radius,
            Math.PI * 0.1,
            Math.PI * 0.9,
            true,
          );
          ctx.quadraticCurveTo(
            this.x,
            this.y + this.radius,
            this.x + Math.cos(Math.PI * 0.1) * this.radius,
            this.y + Math.sin(Math.PI * 0.1) * this.radius,
          );
          ctx.fill();

          // Inner glow
          ctx.fillStyle = "rgba(255,255,255,0.3)";
          ctx.beginPath();
          ctx.arc(
            this.x - this.radius * 0.3,
            this.y - this.radius * 0.4,
            this.radius * 0.3,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Angry Eyes
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.ellipse(this.x - 4, this.y - 2, 3, 4, -0.2, 0, Math.PI * 2);
          ctx.ellipse(this.x + 4, this.y - 2, 3, 4, 0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#f00"; // Red pupils
          ctx.beginPath();
          ctx.arc(this.x - 4, this.y - 2, 1.5, 0, Math.PI * 2);
          ctx.arc(this.x + 4, this.y - 2, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // ... (Player class remains mostly the same, add takeDamage method)
      // I will inject the entire modified script section to ensure correctness.
      class Player {
        constructor() {
          this.x = 0;
          this.y = 0;
          this.radius = 16;
          this.speed = 180;
          this.maxHp = 100;
          this.hp = 100;

          this.level = 1;
          this.exp = 0;
          this.expNeeded = 10;

          // Weapon Stats
          this.attackDamage = 10;
          this.attackCooldown = 0.5; // Seconds
          this.attackTimer = 0;
          this.attackRange = 250;
        }

        update(dt) {
          // Movement
          let vx = 0,
            vy = 0;

          if (keys["ArrowUp"] || keys["w"] || keys["W"]) vy -= 1;
          if (keys["ArrowDown"] || keys["s"] || keys["S"]) vy += 1;
          if (keys["ArrowLeft"] || keys["a"] || keys["A"]) vx -= 1;
          if (keys["ArrowRight"] || keys["d"] || keys["D"]) vx += 1;

          if (vx !== 0 || vy !== 0) {
            const mag = Math.hypot(vx, vy);
            vx /= mag;
            vy /= mag;
          } else if (joystick.active) {
            vx = joystick.dx;
            vy = joystick.dy;
          }

          this.x += vx * this.speed * dt;
          this.y += vy * this.speed * dt;

          // World Bounds
          this.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.x));
          this.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, this.y));

          // Obstacle collision
          obstacles.forEach((obs) => {
            const dx = this.x - obs.x;
            const dy = this.y - (obs.y + obs.radius * 0.5); // Check against base
            const dist = Math.hypot(dx, dy);
            const minDist = this.radius + obs.radius * 0.6;
            if (dist < minDist && dist > 0) {
              const push = minDist - dist;
              this.x += (dx / dist) * push;
              this.y += (dy / dist) * push;
            }
          });

          // Auto Attack Logic
          this.attackTimer += dt;
          if (this.attackTimer >= this.attackCooldown) {
            this.fireProjectile();
          }
        }

        fireProjectile() {
          if (enemies.length === 0) return;

          // Find closest enemy
          let closest = null;
          let minD = Infinity;
          for (let e of enemies) {
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            if (d < minD && d < this.attackRange) {
              minD = d;
              closest = e;
            }
          }

          if (closest) {
            this.attackTimer = 0;
            const dirX = closest.x - this.x;
            const dirY = closest.y - this.y;
            const mag = Math.hypot(dirX, dirY);
            projectiles.push({
              x: this.x,
              y: this.y,
              vx: (dirX / mag) * 400,
              vy: (dirY / mag) * 400,
              radius: 6,
              damage: this.attackDamage,
              life: 1.5, // seconds
            });
          }
        }

        draw(ctx) {
          // Shadow
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y + this.radius,
            this.radius,
            this.radius / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Body (Robe)
          ctx.fillStyle = "#3f51b5"; // Indigo robe
          ctx.beginPath();
          ctx.arc(this.x, this.y + 4, 14, Math.PI, 0); // Shoulders
          ctx.lineTo(this.x + 12, this.y + 16); // Right hem
          ctx.lineTo(this.x - 12, this.y + 16); // Left hem
          ctx.closePath();
          ctx.fill();

          // Belt
          ctx.fillStyle = "#8d6e63";
          ctx.fillRect(this.x - 11, this.y + 8, 22, 4);
          ctx.fillStyle = "#ffeb3b";
          ctx.fillRect(this.x - 3, this.y + 7, 6, 6);

          // Head (Skin)
          ctx.fillStyle = "#ffccbc";
          ctx.beginPath();
          ctx.arc(this.x, this.y - 6, 12, 0, Math.PI * 2);
          ctx.fill();

          // Hair
          ctx.fillStyle = "#5d4037"; // Dark brown
          ctx.beginPath();
          ctx.arc(this.x, this.y - 8, 12.5, Math.PI, 0); // Top hair
          ctx.lineTo(this.x + 14, this.y);
          ctx.lineTo(this.x + 8, this.y - 4);
          ctx.lineTo(this.x - 8, this.y - 4);
          ctx.lineTo(this.x - 14, this.y);
          ctx.closePath();
          ctx.fill();

          // Eyes
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.arc(this.x - 4, this.y - 5, 2.5, 0, Math.PI * 2);
          ctx.arc(this.x + 4, this.y - 5, 2.5, 0, Math.PI * 2);
          ctx.fill();
          // Eye Highlights
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(this.x - 4.5, this.y - 5.5, 1, 0, Math.PI * 2);
          ctx.arc(this.x + 3.5, this.y - 5.5, 1, 0, Math.PI * 2);
          ctx.fill();

          // Weapon (Magic Staff)
          ctx.fillStyle = "#795548"; // Wood
          ctx.fillRect(this.x + 10, this.y - 15, 4, 30);

          // Glowing Orb
          ctx.fillStyle = "#00e5ff"; // Cyan Gem
          ctx.shadowColor = "#00e5ff";
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(this.x + 12, this.y - 18, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0; // Reset

          // Inner orb highlight
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(this.x + 10.5, this.y - 19.5, 2, 0, Math.PI * 2);
          ctx.fill();

          // HP Bar (Above player)
          const hpPct = Math.max(0, this.hp / this.maxHp);
          ctx.fillStyle = "#f00";
          ctx.fillRect(this.x - 15, this.y - 30, 30, 4);
          ctx.fillStyle = "#0f0";
          ctx.fillRect(this.x - 15, this.y - 30, 30 * hpPct, 4);

          // Level Text
          ctx.fillStyle = "#fff";
          ctx.font = "bold 12px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Lv." + this.level, this.x, this.y - 35);
        }
      }

      // --- Core Functions ---
      function resize() {
        // height approx 90% of window height, but don't exceed 95% of window width
        let size = window.innerHeight * 0.9;
        if (size > window.innerWidth * 0.95) {
          size = window.innerWidth * 0.95;
        }

        const container = document.getElementById("gameContainer");
        if (container) {
          container.style.width = size + "px";
          container.style.height = size + "px";
        }

        canvas.width = size;
        canvas.height = size;
      }
      window.addEventListener("resize", resize);
      resize();

      function updateUI() {
        const mins = Math.floor(gameTime / 60)
          .toString()
          .padStart(2, "0");
        const secs = Math.floor(gameTime % 60)
          .toString()
          .padStart(2, "0");
        document.getElementById("timeText").innerText = `${mins}:${secs}`;

        const expPct = (player.exp / player.expNeeded) * 100;
        document.getElementById("expBar").style.width = `${expPct}%`;
        document.getElementById("levelText").innerText = player.level;
        document.getElementById("hpText").innerText =
          `${Math.ceil(player.hp)}/${player.maxHp}`;
      }

      function startGame() {
        document.getElementById("titleScreen").classList.remove("active");
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("hud").style.display = "flex";

        if ("ontouchstart" in window) {
          document.getElementById("joystick-zone").style.display = "block";
        }

        player = new Player();
        enemies = [];
        gems = [];
        items = [];
        projectiles = [];
        damageNumbers = [];
        obstacles = [];

        // Generate random obstacles
        for (let i = 0; i < 40; i++) {
          obstacles.push(new Obstacle());
        }

        gameTime = 0;
        gameState = "playing";
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
      }

      function exitGame() {
        gameState = "title";
        document.getElementById("hud").style.display = "none";
        document.getElementById("joystick-zone").style.display = "none";
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("levelUpScreen").classList.remove("active");
        document.getElementById("titleScreen").classList.add("active");
      }

      // Utility Collision
      function circleIntersect(x1, y1, r1, x2, y2, r2) {
        return Math.hypot(x1 - x2, y1 - y2) < r1 + r2;
      }

      function drawGrid() {
        const gridSize = 40;
        const offsetX = -(camera.x % gridSize);
        const offsetY = -(camera.y % gridSize);

        ctx.strokeStyle = "rgba(0, 0, 0, 0.1)"; // Very subtle dark lines
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = offsetX; x < canvas.width; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
        }
        for (let y = offsetY; y < canvas.height; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
      }

      function gameLoop(time) {
        if (gameState !== "playing") return;

        const dt = (time - lastTime) / 1000;
        lastTime = time;
        const safeDt = Math.min(dt, 0.1);

        gameTime += safeDt;

        // --- 1. UPDATE --- //
        player.update(safeDt);

        // Enemy Spawning
        // Spawn rate increases over time
        const spawnChance = 0.02 + (gameTime / 60) * 0.05;
        // Maximum number of enemies allowed safely on screen (150 cap)
        if (enemies.length < 150 && Math.random() < spawnChance) {
          enemies.push(new Enemy());
        }

        // Update Enemies
        enemies.forEach((e) => e.update(safeDt));

        // Update Projectiles & Collisions
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          p.x += p.vx * safeDt;
          p.y += p.vy * safeDt;
          p.life -= safeDt;

          let hit = false;
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (circleIntersect(p.x, p.y, p.radius, e.x, e.y, e.radius)) {
              e.hp -= p.damage;
              hit = true;

              // Damage number
              damageNumbers.push({
                x: e.x + (Math.random() - 0.5) * 20,
                y: e.y - 10,
                val: p.damage,
                life: 0.8,
                vy: -30,
              });

              if (e.hp <= 0) {
                // Drop Gem or Special Item
                if (Math.random() < 0.05) {
                  // 5% chance for special item
                  const types = ["hp", "bomb", "magnet"];
                  items.push({
                    x: e.x,
                    y: e.y,
                    radius: 10,
                    type: types[Math.floor(Math.random() * types.length)],
                  });
                } else {
                  gems.push({
                    x: e.x,
                    y: e.y,
                    radius: 4,
                    exp: 5,
                  });
                }
                enemies.splice(j, 1);
              }
              break;
            }
          }
          if (hit || p.life <= 0) {
            projectiles.splice(i, 1);
          }
        }

        // Player collecting gems
        for (let i = gems.length - 1; i >= 0; i--) {
          const g = gems[i];
          // Simple magnetic effect when close
          const dist = Math.hypot(player.x - g.x, player.y - g.y);
          if (dist < 80) {
            g.x += ((player.x - g.x) / dist) * 250 * safeDt;
            g.y += ((player.y - g.y) / dist) * 250 * safeDt;
          }
          if (dist < player.radius + g.radius + 5) {
            player.exp += g.exp;
            gems.splice(i, 1);
            // Level up check
            if (player.exp >= player.expNeeded) {
              player.level++;
              player.exp -= player.expNeeded;
              player.expNeeded = Math.floor(player.expNeeded * 1.5);

              triggerLevelUp();
            }
          }
        }

        // Player collecting Special Items
        for (let i = items.length - 1; i >= 0; i--) {
          const item = items[i];
          const dist = Math.hypot(player.x - item.x, player.y - item.y);

          if (dist < player.radius + item.radius + 5) {
            if (item.type === "hp") {
              const heal = player.maxHp * 0.3;
              player.hp = Math.min(player.maxHp, player.hp + heal);
              damageNumbers.push({
                x: player.x,
                y: player.y - 20,
                val: "+HP",
                life: 1,
                vy: -40,
              });
            } else if (item.type === "bomb") {
              // Destroy all enemies
              enemies.forEach((e) => {
                gems.push({ x: e.x, y: e.y, radius: 4, exp: 5 });
                damageNumbers.push({
                  x: e.x,
                  y: e.y - 10,
                  val: "BOOM",
                  life: 0.8,
                  vy: -30,
                });
              });
              enemies = [];
            } else if (item.type === "magnet") {
              // Pull all gems to player immediately
              gems.forEach((g) => {
                const gd = Math.hypot(player.x - g.x, player.y - g.y);
                g.x += ((player.x - g.x) / gd) * 1000 * safeDt;
                g.y += ((player.y - g.y) / gd) * 1000 * safeDt;
              });
            }
            items.splice(i, 1);
          }
        }

        // Enemies hitting player
        enemies.forEach((e) => {
          if (
            circleIntersect(
              player.x,
              player.y,
              player.radius,
              e.x,
              e.y,
              e.radius,
            )
          ) {
            // Simple invincibility frames could be added, for now just constant drain
            player.hp -= e.damage * safeDt;
            if (player.hp <= 0) {
              gameState = "gameover";
              triggerGameOver();
            }
          }
        });

        // Update Damage Numbers
        damageNumbers.forEach((d) => {
          d.y += d.vy * safeDt;
          d.life -= safeDt;
        });
        damageNumbers = damageNumbers.filter((d) => d.life > 0);

        // Camera smoothly follow player
        camera.x += (player.x - canvas.width / 2 - camera.x) * 5 * safeDt;
        camera.y += (player.y - canvas.height / 2 - camera.y) * 5 * safeDt;

        // --- 2. DRAW --- //
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background
        ctx.fillStyle = "#436b4a"; // Soft grass green
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw World Bounds
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.lineWidth = 10;
        ctx.strokeRect(
          -WORLD_SIZE / 2,
          -WORLD_SIZE / 2,
          WORLD_SIZE,
          WORLD_SIZE,
        );

        // Draw Obstacles
        // Sort with enemies for Y-depth
        let renderables = [...obstacles, ...enemies];
        renderables.sort((a, b) => a.y - b.y);

        // Draw Gems (under entities)
        gems.forEach((g) => {
          ctx.fillStyle = "#00f2fe"; // Blue EXP gem
          ctx.beginPath();
          ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        // Draw Special Items
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        items.forEach((item) => {
          let icon = "";
          if (item.type === "hp") icon = "‚ù§Ô∏è";
          else if (item.type === "bomb") icon = "üí£";
          else if (item.type === "magnet") icon = "üß≤";

          // Outer glow for visibility
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 10;
          ctx.fillText(icon, item.x, item.y);
          ctx.shadowBlur = 0;
        });

        // Draw Enemies & Obstacles (sorted)
        renderables.forEach((r) => r.draw(ctx));

        // Draw Projectiles
        projectiles.forEach((p) => {
          ctx.fillStyle = "#00e5ff"; // Cyan glow bullet
          ctx.shadowColor = "#00e5ff";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0; // reset
        });

        // Draw Player
        player.draw(ctx);

        // Draw Damage Numbers
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 14px Outfit, sans-serif";
        damageNumbers.forEach((d) => {
          ctx.globalAlpha = Math.max(0, d.life / 0.8);
          ctx.fillStyle = "#fff";
          ctx.fillText(d.val, d.x, d.y);
          ctx.globalAlpha = 1;
        });

        ctx.restore();

        updateUI();

        if (gameState === "playing") {
          requestAnimationFrame(gameLoop);
        }
      }

      // --- Game Flow & UI Functions ---
      function triggerLevelUp() {
        gameState = "levelup";
        document.getElementById("levelUpScreen").classList.add("active");

        const optionsDiv = document.getElementById("upgradeOptions");
        optionsDiv.innerHTML = "";

        const upgrades = [
          {
            name: "üí™ Damage Up",
            desc: "+5 Attack Damage",
            apply: () => (player.attackDamage += 5),
          },
          {
            name: "‚ö° Attack Speed",
            desc: "-0.05s Cooldown",
            apply: () =>
              (player.attackCooldown = Math.max(
                0.1,
                player.attackCooldown - 0.05,
              )),
          },
          {
            name: "‚ù§Ô∏è Max HP",
            desc: "+20 Max HP & Heal",
            apply: () => {
              player.maxHp += 20;
              player.hp += 20;
            },
          },
          {
            name: "üèÉ Speed Up",
            desc: "+20 Movement Speed",
            apply: () => (player.speed += 20),
          },
          {
            name: "üèπ Range Up",
            desc: "+50 Attack Range",
            apply: () => (player.attackRange += 50),
          },
        ];

        // Pick 3 random
        const shuffled = upgrades.sort(() => 0.5 - Math.random());
        const selected = shuffled.slice(0, 3);

        selected.forEach((upg) => {
          const btn = document.createElement("button");
          btn.className = "btn-main";
          btn.style.fontSize = "1.2rem";
          btn.style.padding = "10px";
          btn.innerHTML = `<strong>${upg.name}</strong><br><span style="font-size:0.9rem; font-weight:normal;">${upg.desc}</span>`;
          btn.onclick = () => {
            upg.apply();
            document.getElementById("levelUpScreen").classList.remove("active");
            gameState = "playing";
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
          };
          optionsDiv.appendChild(btn);
        });
      }

      function triggerGameOver() {
        document.getElementById("gameOverScreen").classList.add("active");
        document.getElementById("hud").style.display = "none";
        document.getElementById("joystick-zone").style.display = "none";

        const mins = Math.floor(gameTime / 60)
          .toString()
          .padStart(2, "0");
        const secs = Math.floor(gameTime % 60)
          .toString()
          .padStart(2, "0");
        document.getElementById("finalTime").innerText = `${mins}:${secs}`;
        document.getElementById("finalLevel").innerText = player.level;

        updateHighScores(Math.floor(gameTime), player.level);
      }

      function updateHighScores(currentTime, currentLevel) {
        let bestTime = parseInt(
          localStorage.getItem("pixelSurvivorBestTime") || 0,
        );
        let bestLevel = parseInt(
          localStorage.getItem("pixelSurvivorBestLevel") || 1,
        );

        if (currentTime > bestTime) {
          bestTime = currentTime;
          localStorage.setItem("pixelSurvivorBestTime", bestTime);
        }
        if (currentLevel > bestLevel) {
          bestLevel = currentLevel;
          localStorage.setItem("pixelSurvivorBestLevel", bestLevel);
        }

        const bMins = Math.floor(bestTime / 60)
          .toString()
          .padStart(2, "0");
        const bSecs = Math.floor(bestTime % 60)
          .toString()
          .padStart(2, "0");

        document.getElementById("titleBestTime").innerText =
          `${bMins}:${bSecs}`;
        document.getElementById("titleBestLevel").innerText = bestLevel;
        if (document.getElementById("goBestTime")) {
          document.getElementById("goBestTime").innerText = `${bMins}:${bSecs}`;
          document.getElementById("goBestLevel").innerText = bestLevel;
        }
      }

      function toggleModal(id, show) {
        if (show) {
          document.getElementById(id).classList.add("active");
        } else {
          document.getElementById(id).classList.remove("active");
        }
      }

      // --- Input Listeners ---
      window.addEventListener("keydown", (e) => (keys[e.key] = true));
      window.addEventListener("keyup", (e) => (keys[e.key] = false));

      const jZone = document.getElementById("joystick-zone");
      const jKnob = document.getElementById("joystick-knob");

      function resetJoystick() {
        joystick.active = false;
        joystick.dx = 0;
        joystick.dy = 0;
        jKnob.style.transform = `translate(0px, 0px)`;
      }

      jZone.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        const rect = jZone.getBoundingClientRect();
        joystick.baseX = rect.left + rect.width / 2;
        joystick.baseY = rect.top + rect.height / 2;
        joystick.active = true;
        handleTouch(touch);
      });

      jZone.addEventListener(
        "touchmove",
        (e) => {
          if (!joystick.active) return;
          e.preventDefault();
          handleTouch(e.touches[0]);
        },
        { passive: false },
      );

      jZone.addEventListener("touchend", resetJoystick);
      jZone.addEventListener("touchcancel", resetJoystick);

      function handleTouch(touch) {
        let dx = touch.clientX - joystick.baseX;
        let dy = touch.clientY - joystick.baseY;
        const dist = Math.hypot(dx, dy);
        const maxDist = 50;

        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }

        jKnob.style.transform = `translate(${dx}px, ${dy}px)`;
        joystick.dx = dx / maxDist;
        joystick.dy = dy / maxDist;
      }

      // Init logic
      updateHighScores(0, 1);
    </script>
  </body>
</html>
