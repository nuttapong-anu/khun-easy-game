<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
    />
    <title>Road Rage Racing</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #111;
        font-family: "Outfit", sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        position: fixed;
        top: 0;
        left: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
      .screen {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        align-items: center;
        z-index: 100;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      .screen.active {
        display: flex;
      }
      #titleScreen {
        justify-content: center;
        background: radial-gradient(ellipse at center, #1a0a2e 0%, #0a0a1e 70%);
      }
      #titleScreen h1 {
        font-size: clamp(1.6rem, 5vw, 3rem);
        color: #fff;
        text-shadow:
          0 0 30px #e040fb,
          0 0 60px #e040fb;
        margin-bottom: 8px;
        animation: glow 2s ease-in-out infinite alternate;
        text-align: center;
      }
      #titleScreen h2 {
        font-size: clamp(0.8rem, 2.5vw, 1.1rem);
        color: #ff4081;
        margin-bottom: 30px;
        letter-spacing: 3px;
      }
      @keyframes glow {
        from {
          text-shadow:
            0 0 20px #e040fb,
            0 0 40px #e040fb;
        }
        to {
          text-shadow:
            0 0 40px #ff4081,
            0 0 80px #ff4081;
        }
      }
      .btn-main {
        padding: 14px 44px;
        font-size: clamp(1rem, 3vw, 1.3rem);
        background: linear-gradient(135deg, #e040fb, #ff4081);
        color: #fff;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-weight: bold;
        letter-spacing: 2px;
        box-shadow: 0 0 25px rgba(224, 64, 251, 0.5);
        transition: all 0.3s;
        font-family: inherit;
      }
      .btn-main:hover {
        transform: scale(1.08);
      }
      .home-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 10px 20px;
        border-radius: 30px;
        text-decoration: none;
        font-weight: bold;
        color: #fff;
        z-index: 200;
        transition: all 0.2s;
        font-size: 0.9rem;
      }
      .home-btn:hover {
        transform: scale(1.05);
        background: rgba(255, 255, 255, 0.2);
      }
      .global-khuno-display {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(251, 192, 45, 0.5);
        padding: 10px 20px;
        border-radius: 30px;
        font-weight: bold;
        color: #fbc02d;
        z-index: 200;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 5px;
        text-shadow: 1px 1px 3px black;
      }
      .coin-display {
        margin-top: 20px;
        padding: 10px 25px;
        border-radius: 16px;
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid rgba(255, 215, 0, 0.2);
        color: #ffd700;
        font-size: clamp(0.85rem, 2vw, 1.1rem);
        font-weight: bold;
      }
      #garageScreen {
        background: linear-gradient(180deg, #0a0a1e, #1a0a2e);
        padding: 15px 10px 100px;
      }
      .shop-header {
        text-align: center;
        margin: 10px 0 15px;
        width: 100%;
      }
      .shop-header h2 {
        font-size: 1.6rem;
        color: #fff;
        margin-bottom: 5px;
      }
      .shop-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        width: 100%;
        max-width: 600px;
        padding: 0 5px;
      }
      .car-card {
        background: rgba(255, 255, 255, 0.06);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 12px;
        text-align: center;
        color: #fff;
        transition: all 0.3s;
        cursor: pointer;
      }
      .car-card.owned {
        border-color: rgba(76, 175, 80, 0.5);
        background: rgba(76, 175, 80, 0.08);
      }
      .car-card.selected {
        border-color: #e040fb;
        background: rgba(224, 64, 251, 0.15);
        box-shadow: 0 0 15px rgba(224, 64, 251, 0.3);
      }
      .car-icon {
        font-size: 2.2rem;
        margin-bottom: 4px;
      }
      .car-name {
        font-weight: 800;
        font-size: 0.95rem;
        margin-bottom: 4px;
      }
      .car-stats {
        font-size: 0.6rem;
        opacity: 0.7;
        line-height: 1.5;
        margin-bottom: 8px;
      }
      .shop-buy {
        padding: 6px 16px;
        border: none;
        border-radius: 20px;
        background: linear-gradient(135deg, #e040fb, #ff4081);
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        font-size: 0.8rem;
        font-family: inherit;
        transition: all 0.2s;
      }
      .shop-buy:hover {
        transform: scale(1.05);
      }
      .shop-buy:disabled {
        background: #555;
        cursor: not-allowed;
        transform: none;
      }
      .shop-badge {
        color: #4caf50;
        font-weight: bold;
        font-size: 0.8rem;
      }
      .shop-bottom {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: 15px;
        background: linear-gradient(transparent, #0a0a1e 30%);
        display: flex;
        justify-content: center;
        z-index: 10;
      }
      #raceHud {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 8px 12px;
        display: none;
        z-index: 50;
        background: linear-gradient(rgba(0, 0, 0, 0.7), transparent);
        pointer-events: none;
      }
      .hud-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }
      .hud-item {
        padding: 4px 10px;
        border-radius: 20px;
        font-size: clamp(0.6rem, 1.7vw, 0.8rem);
        font-weight: bold;
        white-space: nowrap;
      }
      .hud-pos {
        background: rgba(224, 64, 251, 0.2);
        color: #e040fb;
      }
      .hud-speed {
        background: rgba(255, 152, 0, 0.15);
        color: #ff9800;
      }
      .hud-hp {
        background: rgba(244, 67, 54, 0.15);
        color: #ef5350;
      }
      .hud-special {
        background: rgba(255, 215, 0, 0.15);
        color: #ffd700;
        pointer-events: auto;
        cursor: pointer;
        border: 1px solid rgba(255, 215, 0, 0.3);
      }
      .hud-dist {
        background: rgba(76, 175, 80, 0.15);
        color: #76ff03;
      }
      .hud-exit {
        background: rgba(244, 67, 54, 0.8);
        color: #fff;
        pointer-events: auto;
        cursor: pointer;
        border: 1px solid rgba(244, 67, 54, 0.5);
      }
      #touchControls {
        position: fixed;
        bottom: 15px;
        left: 0;
        width: 100%;
        display: none;
        justify-content: space-between;
        align-items: flex-end;
        padding: 0 15px;
        z-index: 60;
        pointer-events: none;
      }
      .touch-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        pointer-events: auto;
      }
      .touch-row {
        display: flex;
        gap: 8px;
      }
      .touch-btn {
        width: 65px;
        height: 65px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.12);
        border: 2px solid rgba(255, 255, 255, 0.25);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.8rem;
        color: rgba(255, 255, 255, 0.6);
        pointer-events: auto;
      }
      @media (max-width: 768px) {
        #touchControls {
          display: flex;
        }
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        background: rgba(0, 0, 0, 0.85);
        text-align: center;
        padding: 20px;
        color: #fff;
      }
      .overlay.active {
        display: flex;
      }
      .overlay h2 {
        font-size: clamp(1.5rem, 5vw, 2.5rem);
        margin-bottom: 15px;
      }
      .overlay .sub {
        font-size: clamp(1rem, 3vw, 1.3rem);
        margin-bottom: 8px;
      }
      .overlay .info {
        font-size: clamp(0.8rem, 2vw, 1rem);
        color: #aaa;
        margin-bottom: 20px;
      }
      .standings {
        text-align: left;
        margin-bottom: 20px;
        font-size: clamp(0.7rem, 2vw, 0.9rem);
      }
      .standings .srow {
        padding: 4px 14px;
        border-radius: 8px;
        margin: 3px 0;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .standings .srow.me {
        background: rgba(224, 64, 251, 0.2);
        border: 1px solid rgba(224, 64, 251, 0.3);
      }
      #countdown {
        position: fixed;
        top: 35%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 150;
        font-size: clamp(3rem, 10vw, 6rem);
        color: #fff;
        font-weight: 800;
        text-shadow: 0 0 40px #e040fb;
        display: none;
        pointer-events: none;
      }

      /* Modal Style */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(8px);
        z-index: 300;
        display: none;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      .modal-overlay.active {
        display: flex;
      }
      .modal-content {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        padding: 30px;
        max-width: 500px;
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
        color: #fff;
        position: relative;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      }
      .modal-close {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: #fff;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
      }
      .modal-content h3 {
        color: #e040fb;
        margin: 20px 0 10px;
        font-size: 1.2rem;
        border-bottom: 2px solid rgba(224, 64, 251, 0.3);
        padding-bottom: 5px;
      }
      .modal-content h3:first-of-type {
        margin-top: 0;
      }
      .modal-content p,
      .modal-content li {
        font-size: 0.9rem;
        line-height: 1.6;
        color: #ccc;
        margin-bottom: 8px;
        font-family: inherit;
        transition: all 0.2s;
      }
      .modal-content ul {
        padding-left: 20px;
      }
      .btn-info {
        margin-top: 15px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 10px 25px;
        border-radius: 30px;
        cursor: pointer;
        font-weight: bold;
        font-family: inherit;
        transition: all 0.2s;
      }
      .btn-info:hover {
        background: rgba(255, 255, 255, 0.2);
      }
    </style>
  </head>
  <body>
    <div id="titleScreen" class="screen active">
      <a href="index.html" class="home-btn">üè† Home</a>
      <h1>üèÅ ROAD RAGE</h1>
      <h2>RACING</h2>
      <button class="btn-main" onclick="showGarage()">‚ñ∂ START</button>
      <div
        class="global-khuno-display"
        style="
          position: absolute;
          top: 15px;
          right: 15px;
          color: #fbc02d;
          font-weight: bold;
          font-size: 1.2rem;
          background: rgba(0, 0, 0, 0.5);
          padding: 5px 15px;
          border-radius: 20px;
          z-index: 100;
        "
      >
        üí∞ Khuno: <span id="titleCoins">0</span> K
      </div>
      <button class="btn-info" onclick="toggleModal('howToModal', true)">
        ‚ùì ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô
      </button>
    </div>

    <!-- How to Play Modal -->
    <div id="howToModal" class="modal-overlay">
      <div class="modal-content">
        <button class="modal-close" onclick="toggleModal('howToModal', false)">
          ‚úï
        </button>
        <h2 style="text-align: center; color: #fff; margin-bottom: 20px">
          üèÅ ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô
        </h2>

        <h3>üéÆ ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°</h3>
        <ul>
          <li>
            <strong>‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå</strong>: ‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ó‡∏¥‡∏®, Spacebar ‡πÉ‡∏ä‡πâ‡πÑ‡∏≠‡πÄ‡∏ó‡∏°
          </li>
          <li>
            <strong>‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠</strong>: ‡∏õ‡∏∏‡πà‡∏°‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ó‡∏¥‡∏®, ‡πÅ‡∏ï‡∏∞‡∏ä‡πà‡∏≠‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ
          </li>
        </ul>

        <h3>üöó ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÅ‡∏Ç‡πà‡∏á</h3>
        <p>
          ‡πÅ‡∏Ç‡πà‡∏á‡∏Å‡∏±‡∏ö AI 4 ‡∏Ñ‡∏±‡∏ô ‡πÉ‡∏ô 5 ‡πÄ‡∏•‡∏ô ‡πÑ‡∏õ‡πÉ‡∏´‡πâ‡∏ñ‡∏∂‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ä‡∏±‡∏¢ (12 ‡∏Å‡∏°.) ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î!
          ‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡∏¢‡∏¥‡πà‡∏á‡∏î‡∏µ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö
          <strong>KHUNO (K)</strong> ‡∏™‡∏∞‡∏™‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏£‡∏∞‡πÄ‡∏õ‡πã‡∏≤‡∏Å‡∏•‡∏≤‡∏á‡∏¢‡∏¥‡πà‡∏á‡πÄ‡∏¢‡∏≠‡∏∞!
        </p>
        <p>
          ‚ö†Ô∏è <strong>‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡∏Ç‡πâ‡∏≤‡∏á‡∏ó‡∏≤‡∏á!</strong> ‡∏´‡∏≤‡∏Å‡∏Ç‡∏±‡∏ö‡∏ä‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ, ‡∏´‡∏¥‡∏ô
          ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡πâ‡∏≤‡∏¢‡∏ö‡∏≠‡∏Å‡∏ó‡∏≤‡∏á ‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ï‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß
        </p>

        <h3>üì¶ ‡πÑ‡∏≠‡πÄ‡∏ó‡∏°</h3>
        <ul>
          <li>üöÄ <strong>‡∏ö‡∏π‡∏™‡∏ï‡πå</strong>: ‡πÄ‡∏£‡πà‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß</li>
          <li>üõ°Ô∏è <strong>‡πÇ‡∏•‡πà</strong>: ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á</li>
          <li>üî• <strong>‡∏à‡∏£‡∏ß‡∏î</strong>: ‡∏¢‡∏¥‡∏á‡πÉ‡∏™‡πà‡∏£‡∏ñ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤</li>
          <li>‚ö° <strong>‡∏ä‡πá‡∏≠‡∏ï</strong>: ‡∏ä‡πá‡∏≠‡∏ï‡∏Ñ‡∏π‡πà‡πÅ‡∏Ç‡πà‡∏á‡∏£‡∏≠‡∏ö‡∏Ç‡πâ‡∏≤‡∏á</li>
          <li>
            üõ¢Ô∏è <strong>‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô</strong>: ‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏ß‡πâ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏ä‡πâ‡∏≤‡∏•‡∏á
          </li>
          <li>‚ù§Ô∏è <strong>‡∏ã‡πà‡∏≠‡∏°</strong>: ‡∏ü‡∏∑‡πâ‡∏ô‡∏ü‡∏π HP 50%</li>
        </ul>
        <h3>üö™ ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏£‡∏¥‡∏°</h3>
        <p>
          ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°
          <strong>EXIT</strong> ‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏Ç‡πà‡∏á‡∏Ç‡∏±‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠
        </p>

        <h3>üèéÔ∏è ‡∏£‡∏ñ‡πÅ‡∏Ç‡πà‡∏á</h3>
        <p>
          ‡∏™‡∏∞‡∏™‡∏°‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Å‡∏£‡∏ñ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡πÅ‡∏•‡∏∞‡∏™‡πÄ‡∏ï‡∏ï‡∏±‡∏™‡πÄ‡∏â‡∏û‡∏≤‡∏∞ (‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß,
          ‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡πÄ‡∏£‡πà‡∏á, HP, ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)
        </p>
      </div>
    </div>
    <div id="garageScreen" class="screen">
      <a href="index.html" class="home-btn">üè† Home</a>
      <div
        class="global-khuno-display"
        style="
          position: absolute;
          top: 15px;
          right: 15px;
          color: #fbc02d;
          font-weight: bold;
          font-size: 1.2rem;
          background: rgba(0, 0, 0, 0.5);
          padding: 5px 15px;
          border-radius: 20px;
          z-index: 100;
        "
      >
        üí∞ Khuno: <span id="garageCoins">0</span> K
      </div>
      <div class="shop-header">
        <h2>üîß GARAGE</h2>
      </div>
      <div class="shop-grid" id="carGrid"></div>
      <div
        style="width: 100%; max-width: 600px; padding: 0 5px; margin-top: 15px"
      >
        <div
          style="
            color: #fff;
            font-weight: 800;
            text-align: center;
            margin-bottom: 8px;
          "
        >
          üèüÔ∏è SELECT TRACK
        </div>
        <div class="shop-grid" id="trackGrid"></div>
      </div>
      <div class="shop-bottom">
        <button class="btn-main" onclick="startRace()">üèÅ RACE!</button>
      </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="raceHud">
      <div class="hud-row">
        <span class="hud-item hud-pos" id="hudPos">POS 1/7</span>
        <span class="hud-item hud-speed" id="hudSpeed">0 km/h</span>
        <span class="hud-item hud-hp" id="hudHp">‚ù§Ô∏è 100</span>
        <span
          class="hud-item hud-special"
          id="hudSpecial"
          onclick="useSpecial()"
          >üì¶ ---</span
        >
        <span class="hud-item hud-dist" id="hudDist">üìç 0 / 12 km</span>
        <span class="hud-item hud-exit" onclick="exitRace()">üö™ EXIT</span>
      </div>
    </div>
    <div id="touchControls">
      <div class="touch-group">
        <div class="touch-btn" id="btnUp">‚ñ≤</div>
        <div class="touch-btn" id="btnDown">‚ñº</div>
      </div>
      <div class="touch-group">
        <div class="touch-row">
          <div class="touch-btn" id="btnLeft">‚óÄ</div>
          <div class="touch-btn" id="btnRight">‚ñ∂</div>
        </div>
      </div>
    </div>
    <div id="resultOverlay" class="overlay">
      <h2 id="resultTitle">üèÅ RACE COMPLETE</h2>
      <div class="sub" id="resultSub"></div>
      <div class="standings" id="resultStandings"></div>
      <div class="info" id="resultInfo"></div>
      <button class="btn-main" onclick="backToGarage()">üîß Garage</button>
    </div>
    <div id="countdown"></div>

    <script>
      function toggleModal(id, show) {
        document.getElementById(id).classList.toggle("active", show);
      }
      // ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ
      const RACE_DIST = 12000,
        NUM_RACERS = 5,
        LANES = 5;
      const REWARDS = [150, 100, 70, 40, 15];
      const TRACKS = [
        {
          id: "city",
          name: "City Night",
          icon: "üèôÔ∏è",
          bg: "#1a1a2e",
          grass: "#1a3d0c",
          grassD: "#245210",
          road: "#333",
          edge: "#fff",
          lane: "rgba(255,255,255,.2)",
          objects: ["üè¢", "üè¨", "üè£", "üí°", "üå≥", "üö¶"],
        },
        {
          id: "desert",
          name: "Desert Highway",
          icon: "üèúÔ∏è",
          bg: "#3b2a15",
          grass: "#8B7355",
          grassD: "#9C8565",
          road: "#5a4a35",
          edge: "#d4a04a",
          lane: "rgba(255,200,80,.2)",
          objects: ["üåµ", "üê™", "üíÄ", "ü™®", "üèúÔ∏è"],
        },
        {
          id: "forest",
          name: "Forest Road",
          icon: "üå≤",
          bg: "#0a1a0a",
          grass: "#1e4420",
          grassD: "#2a5c2e",
          road: "#2a2a2a",
          edge: "#8bc34a",
          lane: "rgba(139,195,74,.2)",
          objects: ["üå≤", "üå≥", "üçÑ", "üèïÔ∏è", "ü¶å", "ü™µ"],
        },
      ];
      let currentTrack = 0;
      const CARS = [
        {
          id: "runner",
          name: "Runner",
          icon: "üöó",
          cost: 0,
          maxSpeed: 200,
          accel: 30,
          hp: 100,
          handling: 5,
          weapon: "minigun",
          color: "#4CAF50",
          desc: "Balanced starter",
        },
        {
          id: "blaze",
          name: "Blaze",
          icon: "üèéÔ∏è",
          cost: 12,
          maxSpeed: 240,
          accel: 40,
          hp: 70,
          handling: 6,
          weapon: "flame",
          color: "#FF5722",
          desc: "Fast & fragile",
        },
        {
          id: "titan",
          name: "Titan",
          icon: "üöõ",
          cost: 25,
          maxSpeed: 165,
          accel: 22,
          hp: 200,
          handling: 3,
          weapon: "cannon",
          color: "#607D8B",
          desc: "Slow but tough",
        },
        {
          id: "storm",
          name: "Storm",
          icon: "‚ö°",
          cost: 40,
          maxSpeed: 260,
          accel: 50,
          hp: 60,
          handling: 8,
          weapon: "shock",
          color: "#FF9800",
          desc: "Lightning speed",
        },
        {
          id: "shadow",
          name: "Shadow",
          icon: "üåë",
          cost: 60,
          maxSpeed: 220,
          accel: 35,
          hp: 90,
          handling: 6,
          weapon: "homing",
          color: "#9C27B0",
          desc: "Stealth tracker",
        },
        {
          id: "fury",
          name: "Fury",
          icon: "üíÄ",
          cost: 90,
          maxSpeed: 240,
          accel: 38,
          hp: 150,
          handling: 5,
          weapon: "rockets",
          color: "#f44336",
          desc: "Devastating power",
        },
      ];
      const WEAPONS = {
        minigun: { dmg: 5, rate: 0.15, speed: 600, color: "#ffeb3b" },
        flame: { dmg: 3, rate: 0.08, speed: 400, color: "#ff5722" },
        cannon: { dmg: 20, rate: 0.8, speed: 500, color: "#90a4ae" },
        shock: { dmg: 10, rate: 0.35, speed: 700, color: "#ff9800" },
        homing: { dmg: 15, rate: 0.6, speed: 350, color: "#ce93d8" },
        rockets: { dmg: 12, rate: 0.4, speed: 550, color: "#ef5350" },
      };
      const ITEM_TYPES = [
        { id: "boost", icon: "üöÄ", name: "Boost" },
        { id: "shield", icon: "üõ°Ô∏è", name: "Shield" },
        { id: "rocket", icon: "üî•", name: "Rocket" },
        { id: "zap", icon: "‚ö°", name: "Zap" },
        { id: "oil", icon: "üõ¢Ô∏è", name: "Oil" },
        { id: "repair", icon: "‚ù§Ô∏è", name: "Repair" },
      ];

      // ‚îÄ‚îÄ CANVAS ‚îÄ‚îÄ
      const canvas = document.getElementById("gameCanvas"),
        ctx = canvas.getContext("2d");
      const ASPECT = 9 / 16;
      let GW, GH;
      function resize() {
        let ww = innerWidth,
          wh = innerHeight;
        if (ww / wh > ASPECT) {
          GH = wh;
          GW = Math.floor(wh * ASPECT);
        } else {
          GW = ww;
          GH = Math.floor(ww / ASPECT);
        }
        canvas.width = GW;
        canvas.height = GH;
        canvas.style.width = GW + "px";
        canvas.style.height = GH + "px";
        canvas.style.left = Math.floor((ww - GW) / 2) + "px";
        canvas.style.top = Math.floor((wh - GH) / 2) + "px";
      }
      resize();
      addEventListener("resize", resize);

      // ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
      let coins = 0,
        ownedCars = ["runner"],
        selectedCar = "runner",
        gameState = "title";
      let racers = [],
        raceItems = [],
        projectiles = [],
        particles = [],
        oilSlicks = [],
        roadsideObjects = [];
      let keys = { up: false, down: false, left: false, right: false };
      let touchU = false,
        touchD = false,
        touchL = false,
        touchR = false;
      let lastTime = 0,
        raceTime = 0,
        finishOrder = [];

      // ‚îÄ‚îÄ PERSISTENCE ‚îÄ‚îÄ
      function save() {
        localStorage.setItem("rr_owned", JSON.stringify(ownedCars));
        localStorage.setItem("rr_selected", selectedCar);
        localStorage.setItem("rr_track", currentTrack);
      }
      function load() {
        khunoCoins = parseInt(localStorage.getItem("khunoCoins") || "0");
        try {
          ownedCars = JSON.parse(localStorage.getItem("rr_owned")) || [
            "runner",
          ];
        } catch (e) {
          ownedCars = ["runner"];
        }
        if (!ownedCars.includes("runner")) ownedCars.unshift("runner");
        selectedCar = localStorage.getItem("rr_selected") || "runner";
        if (!ownedCars.includes(selectedCar)) selectedCar = "runner";
        currentTrack = parseInt(localStorage.getItem("rr_track") || "0");
      }

      document.addEventListener("DOMContentLoaded", () => {
        const tEl = document.getElementById("titleCoins");
        if (tEl)
          tEl.innerText = parseInt(localStorage.getItem("khunoCoins") || "0");
      });

      // ‚îÄ‚îÄ SCREEN ‚îÄ‚îÄ
      function showScreen(id) {
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        ["raceHud", "touchControls"].forEach(
          (i) => (document.getElementById(i).style.display = "none"),
        );
        document
          .querySelectorAll(".overlay")
          .forEach((o) => o.classList.remove("active"));
        if (id) document.getElementById(id).classList.add("active");
      }
      function showGarage() {
        showScreen("garageScreen");
        gameState = "garage";
        renderGarage();
      }
      function renderGarage() {
        const g = document.getElementById("carGrid");
        g.innerHTML = "";
        CARS.forEach((car) => {
          const own = ownedCars.includes(car.id),
            sel = selectedCar === car.id,
            aff = khunoCoins >= car.cost;
          g.innerHTML += `<div class="car-card ${own ? "owned" : ""} ${sel ? "selected" : ""}" onclick="${own ? `selectCar('${car.id}')` : ""}">
        <div class="car-icon">${car.icon}</div><div class="car-name">${car.name}</div>
        <div class="car-stats">SPD ${car.maxSpeed} ¬∑ ACC ${car.accel}<br>HP ${car.hp} ¬∑ HND ${car.handling}<br>${car.desc}</div>
        ${
          own
            ? sel
              ? '<div class="shop-badge">‚úì SELECTED</div>'
              : '<div class="shop-badge" style="color:#aaa">OWNED</div>'
            : `<button class="shop-buy" ${!aff ? "disabled" : ""} onclick="event.stopPropagation();buyCar('${car.id}')">${car.cost === 0 ? "FREE" : car.cost + " K"}</button>`
        }
      </div>`;
        });
        document.getElementById("garageCoins").textContent = khunoCoins;
        document.getElementById("titleCoins").textContent = khunoCoins;
        renderTracks();
      }
      function selectCar(id) {
        selectedCar = id;
        save();
        renderGarage();
      }
      function buyCar(id) {
        const c = CARS.find((x) => x.id === id);
        if (!c || ownedCars.includes(id) || khunoCoins < c.cost) return;
        khunoCoins -= c.cost;
        localStorage.setItem("khunoCoins", khunoCoins);
        ownedCars.push(id);
        selectedCar = id;
        save();
        renderGarage();
      }
      function renderTracks() {
        const g = document.getElementById("trackGrid");
        if (!g) return;
        g.innerHTML = "";
        TRACKS.forEach((t, i) => {
          g.innerHTML += `<div class="car-card ${currentTrack === i ? "selected" : "owned"}" onclick="currentTrack=${i};save();renderTracks()">
              <div class="car-icon">${t.icon}</div><div class="car-name">${t.name}</div>
              ${currentTrack === i ? '<div class="shop-badge">‚úì SELECTED</div>' : ""}
            </div>`;
        });
      }

      // ‚îÄ‚îÄ ROAD HELPERS ‚îÄ‚îÄ
      function roadW() {
        return GW * 0.65;
      }
      function roadL() {
        return (GW - roadW()) / 2;
      }
      function laneW() {
        return roadW() / LANES;
      }
      function laneX(l) {
        return roadL() + (l + 0.5) * laneW();
      }

      // ‚îÄ‚îÄ RACER ‚îÄ‚îÄ
      class Racer {
        constructor(type, lane, isPlayer) {
          this.type = type;
          this.isPlayer = isPlayer;
          this.dist = 0;
          this.lane = lane;
          this.targetLane = lane;
          this.laneX = laneX(lane);
          this.speed = 0;
          this.maxSpeed = type.maxSpeed;
          this.accel = type.accel;
          this.hp = type.hp;
          this.maxHp = type.hp;
          this.handling = type.handling;
          this.weaponTimer = 0;
          this.stunTimer = 0;
          this.boostTimer = 0;
          this.oilTimer = 0;
          this.shieldActive = false;
          this.special = null;
          this.finished = false;
          this.finishPos = 0;
          this.spinTimer = 0;
          this.bumpCD = 0;
          this.color = type.color;
          this.aiLT = 2 + Math.random() * 3;
        }
        get effMax() {
          let s = this.maxSpeed;
          if (this.boostTimer > 0) s *= 1.4;
          if (this.oilTimer > 0) s *= 0.5;
          if (this.stunTimer > 0) s *= 0.15;
          return s;
        }
        update(dt) {
          if (this.finished) {
            this.speed = Math.max(0, this.speed - 100 * dt);
            return;
          }
          if (this.stunTimer > 0) this.stunTimer -= dt;
          if (this.boostTimer > 0) this.boostTimer -= dt;
          if (this.oilTimer > 0) this.oilTimer -= dt;
          if (this.bumpCD > 0) this.bumpCD -= dt;
          if (this.spinTimer > 0) {
            this.spinTimer -= dt;
            this.speed = Math.max(0, this.speed - 150 * dt);
            // Still allow lane transition during spin
            const tx = laneX(this.targetLane);
            const dx = tx - this.laneX;
            if (Math.abs(dx) > 1) {
              const step = Math.min(Math.abs(dx), this.handling * 60 * dt);
              this.laneX += Math.sign(dx) * step;
            } else {
              this.laneX = tx;
              this.lane = this.targetLane;
            }
            return;
          }
          this.weaponTimer -= dt;
          const em = this.effMax;
          if (this.isPlayer) {
            if (keys.up || touchU)
              this.speed = Math.min(em, this.speed + this.accel * dt * 2);
            else if (keys.down || touchD)
              this.speed = Math.max(0, this.speed - this.accel * dt * 4);
            else this.speed = Math.min(em, this.speed + this.accel * dt * 0.5);
            if (keys.left || touchL) {
              if (this.targetLane > 0 && this.lane === this.targetLane)
                this.targetLane--;
            }
            if (keys.right || touchR) {
              if (this.targetLane < LANES - 1 && this.lane === this.targetLane)
                this.targetLane++;
            }
          } else {
            this.aiUpdate(dt);
          }
          this.speed = Math.max(0, Math.min(em, this.speed));
          this.dist += this.speed * dt;
          // Lane transition
          const tx = laneX(this.targetLane);
          const dx = tx - this.laneX;
          if (Math.abs(dx) > 1) {
            const step = Math.min(Math.abs(dx), this.handling * 60 * dt);
            this.laneX += Math.sign(dx) * step;
          } else {
            this.laneX = tx;
            this.lane = this.targetLane;
          }
          if (this.dist >= RACE_DIST && !this.finished) {
            this.finished = true;
            finishOrder.push(this);
            this.finishPos = finishOrder.length;
          }
        }
        aiUpdate(dt) {
          const p = racers.find((r) => r.isPlayer);
          let ts = this.maxSpeed * (0.85 + Math.random() * 0.3);
          if (p && this.dist > p.dist + 800) ts *= 0.88;
          if (p && this.dist < p.dist - 600) ts *= 1.12;
          ts = Math.min(ts, this.effMax);
          if (this.speed < ts) this.speed += this.accel * dt;
          else this.speed -= this.accel * dt * 0.5;
          this.aiLT -= dt;
          if (this.aiLT <= 0) {
            this.aiLT = 1.5 + Math.random() * 3;
            let best = this.lane;
            for (let it of raceItems) {
              if (
                !it.collected &&
                it.dist > this.dist &&
                it.dist < this.dist + 400
              ) {
                best = it.lane;
                break;
              }
            }
            if (Math.random() < 0.3)
              best = Math.max(
                0,
                Math.min(LANES - 1, this.lane + (Math.random() < 0.5 ? -1 : 1)),
              );
            this.targetLane = best;
          }
          if (this.special && Math.random() < 0.005) this.useSpecialItem();
          // AI weapon fire
          if (this.weaponTimer <= 0) {
            const w = WEAPONS[this.type.weapon];
            let tgt = null,
              bd = Infinity;
            racers.forEach((r) => {
              if (
                r !== this &&
                !r.finished &&
                r.dist > this.dist &&
                r.dist < this.dist + 400
              ) {
                const d = r.dist - this.dist;
                if (d < bd) {
                  bd = d;
                  tgt = r;
                }
              }
            });
            if (tgt) {
              projectiles.push({
                x: this.laneX,
                y: 0,
                dist: this.dist,
                speed: w.speed,
                dmg: w.dmg,
                color: w.color,
                owner: this,
                target: tgt,
              });
              this.weaponTimer = w.rate;
            }
          }
        }
        hit(dmg) {
          if (this.shieldActive) {
            this.shieldActive = false;
            return;
          }
          this.hp -= dmg;
          this.stunTimer = Math.max(this.stunTimer, 0.3);
          if (this.hp <= 0) {
            this.hp = Math.floor(this.maxHp * 0.3);
            this.spinTimer = 1.5;
            this.speed *= 0.3;
          }
        }
        useSpecialItem() {
          if (!this.special) return;
          const s = this.special;
          this.special = null;
          if (s === "boost") {
            this.boostTimer = 3;
          } else if (s === "shield") {
            this.shieldActive = true;
          } else if (s === "rocket") {
            let tgt = null,
              bd = Infinity;
            racers.forEach((r) => {
              if (r !== this && !r.finished && r.dist > this.dist) {
                const d = r.dist - this.dist;
                if (d < bd) {
                  bd = d;
                  tgt = r;
                }
              }
            });
            if (tgt)
              projectiles.push({
                x: this.laneX,
                y: 0,
                dist: this.dist,
                speed: 800,
                dmg: 25,
                color: "#ff1744",
                owner: this,
                target: tgt,
              });
          } else if (s === "zap") {
            racers.forEach((r) => {
              if (
                r !== this &&
                !r.finished &&
                Math.abs(r.dist - this.dist) < 300
              )
                r.stunTimer = 1.5;
            });
            for (let i = 0; i < 15; i++)
              particles.push({
                x: this.laneX + (Math.random() - 0.5) * 100,
                dist: this.dist + (Math.random() - 0.5) * 200,
                life: 20,
                color: "#ffeb3b",
                sz: 3,
              });
          } else if (s === "oil") {
            oilSlicks.push({ lane: this.lane, dist: this.dist - 50, life: 15 });
          } else if (s === "repair") {
            this.hp = Math.min(this.maxHp, this.hp + 40);
          }
          updateHud();
        }
      }

      // ‚îÄ‚îÄ RACE INIT ‚îÄ‚îÄ
      function startRace() {
        showScreen(null);
        gameState = "countdown";
        racers = [];
        projectiles = [];
        particles = [];
        oilSlicks = [];
        raceItems = [];
        roadsideObjects = [];
        finishOrder = [];
        raceTime = 0;
        const playerType = CARS.find((c) => c.id === selectedCar) || CARS[0];
        const pl = new Racer(playerType, 2, true);
        racers.push(pl);
        // AI cars
        const aiTypes = CARS.filter((c) => c.id !== selectedCar);
        for (let i = 0; i < NUM_RACERS - 1; i++) {
          const t = aiTypes[i % aiTypes.length];
          const lane = i < 2 ? i : i + 1 >= LANES ? i % LANES : i + 1;
          racers.push(new Racer(t, lane % LANES, false));
        }
        // Generate items
        for (let d = 300; d < RACE_DIST - 500; d += 120 + Math.random() * 180) {
          raceItems.push({
            dist: d,
            lane: Math.floor(Math.random() * LANES),
            type: ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)],
            collected: false,
          });
        }
        // Generate roadside objects
        const trkConfig = TRACKS[currentTrack];
        if (trkConfig.objects) {
          for (
            let d = -1000;
            d < RACE_DIST + 2000;
            d += 60 + Math.random() * 100
          ) {
            // Left side
            roadsideObjects.push({
              dist: d + (Math.random() - 0.5) * 50,
              isLeft: true,
              offsetX: -30 - Math.random() * 150,
              icon: trkConfig.objects[
                Math.floor(Math.random() * trkConfig.objects.length)
              ],
              size: 25 + Math.random() * 25,
            });
            // Right side
            roadsideObjects.push({
              dist: d + (Math.random() - 0.5) * 50,
              isLeft: false,
              offsetX: 30 + Math.random() * 150,
              icon: trkConfig.objects[
                Math.floor(Math.random() * trkConfig.objects.length)
              ],
              size: 25 + Math.random() * 25,
            });
          }
          // Sort by dist descending so further objects are drawn first
          roadsideObjects.sort((a, b) => b.dist - a.dist);
        }
        document.getElementById("raceHud").style.display = "block";
        document.getElementById("touchControls").style.display = "flex";
        // Countdown
        let c = 3;
        const el = document.getElementById("countdown");
        el.style.display = "block";
        el.textContent = c;
        if (window.countdownInterval) clearInterval(window.countdownInterval);
        window.countdownInterval = setInterval(() => {
          c--;
          if (c > 0) {
            el.textContent = c;
          } else if (c === 0) {
            el.textContent = "GO!";
            el.style.color = "#76ff03";
          } else {
            clearInterval(window.countdownInterval);
            el.style.display = "none";
            el.style.color = "#fff";
            gameState = "racing";
            lastTime = performance.now();
            requestAnimationFrame(loop);
          }
        }, 800);
      }

      function updateHud() {
        const p = racers.find((r) => r.isPlayer);
        if (!p) return;
        const sorted = [...racers].sort((a, b) => b.dist - a.dist);
        const pos = sorted.indexOf(p) + 1;
        const suf = ["st", "nd", "rd"][pos - 1] || "th";
        document.getElementById("hudPos").textContent =
          pos + suf + " / " + NUM_RACERS;
        document.getElementById("hudSpeed").textContent =
          Math.round(p.speed) + " km/h";
        document.getElementById("hudHp").textContent =
          "‚ù§Ô∏è " + Math.max(0, Math.round(p.hp));
        document.getElementById("hudSpecial").textContent = p.special
          ? ITEM_TYPES.find((i) => i.id === p.special).icon + " USE"
          : "üì¶ ---";
        const distKm = (Math.min(p.dist, RACE_DIST) / 1000).toFixed(1);
        const totalKm = (RACE_DIST / 1000).toFixed(0);
        document.getElementById("hudDist").textContent =
          "üìç " + distKm + " / " + totalKm + " km";
      }

      function useSpecial() {
        const p = racers.find((r) => r.isPlayer);
        if (p) p.useSpecialItem();
      }

      // ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ
      function update(dt) {
        if (gameState !== "racing") return;
        raceTime += dt;
        const player = racers.find((r) => r.isPlayer);
        // Update racers
        racers.forEach((r) => r.update(dt));
        // Player weapon auto-fire
        if (
          player &&
          player.weaponTimer <= 0 &&
          !player.finished &&
          player.spinTimer <= 0
        ) {
          const w = WEAPONS[player.type.weapon];
          let tgt = null,
            bd = Infinity;
          racers.forEach((r) => {
            if (
              r !== player &&
              !r.finished &&
              r.dist > player.dist &&
              r.dist < player.dist + 400
            ) {
              const d = r.dist - player.dist;
              if (d < bd) {
                bd = d;
                tgt = r;
              }
            }
          });
          if (tgt) {
            projectiles.push({
              x: player.laneX,
              y: 0,
              dist: player.dist,
              speed: w.speed,
              dmg: w.dmg,
              color: w.color,
              owner: player,
              target: tgt,
            });
            player.weaponTimer = w.rate;
          }
        }
        // Projectiles
        projectiles = projectiles.filter((p) => {
          p.dist += p.speed * dt;
          // Check hit target
          if (p.target && !p.target.finished) {
            if (
              Math.abs(p.dist - p.target.dist) < 30 &&
              Math.abs(p.x - p.target.laneX) < laneW() * 0.6
            ) {
              p.target.hit(p.dmg);
              for (let i = 0; i < 5; i++)
                particles.push({
                  x: p.target.laneX + (Math.random() - 0.5) * 20,
                  dist: p.target.dist,
                  life: 15,
                  color: p.color,
                  sz: 2 + Math.random() * 3,
                });
              return false;
            }
          }
          return (
            p.dist < (player ? player.dist + GH : 0) &&
            p.dist > (player ? player.dist : 0) - 200
          );
        });
        // Item collection
        raceItems.forEach((it) => {
          if (it.collected) return;
          racers.forEach((r) => {
            if (
              !r.finished &&
              r.lane === it.lane &&
              Math.abs(r.dist - it.dist) < 35
            ) {
              it.collected = true;
              if (!r.special) r.special = it.type.id;
              else {
                // Auto-use if already have one
                const old = r.special;
                r.special = it.type.id;
                r.useSpecialItem();
              }
              for (let i = 0; i < 8; i++)
                particles.push({
                  x: laneX(it.lane) + (Math.random() - 0.5) * 30,
                  dist: it.dist,
                  life: 20,
                  color: "#ffd700",
                  sz: 2 + Math.random() * 2,
                });
            }
          });
        });
        // Oil slicks
        oilSlicks = oilSlicks.filter((o) => {
          o.life -= dt;
          racers.forEach((r) => {
            if (
              !r.finished &&
              r.lane === o.lane &&
              Math.abs(r.dist - o.dist) < 30 &&
              r.oilTimer <= 0
            ) {
              r.oilTimer = 2;
              r.stunTimer = 0.5;
            }
          });
          return o.life > 0;
        });
        // Bumping
        for (let i = 0; i < racers.length; i++) {
          for (let j = i + 1; j < racers.length; j++) {
            const a = racers[i],
              b = racers[j];
            if (a.finished || b.finished) continue;
            if (a.bumpCD > 0 || b.bumpCD > 0) continue;
            if (
              Math.abs(a.laneX - b.laneX) < laneW() * 0.7 &&
              Math.abs(a.dist - b.dist) < 25
            ) {
              const dmg = Math.abs(a.speed - b.speed) * 0.05 + 2;
              a.hit(dmg);
              b.hit(dmg);
              a.bumpCD = 1;
              b.bumpCD = 1;
              if (a.dist > b.dist) b.dist -= 30;
              else a.dist -= 30;
            }
          }
        }
        // Particles
        particles = particles.filter((p) => {
          p.life--;
          return p.life > 0;
        });
        // Check race end
        if (player && player.finished) {
          setTimeout(() => endRace(), 500);
          gameState = "finishing";
        }
        // Force-end if all AI finished
        const allAI = racers.filter((r) => !r.isPlayer);
        if (allAI.every((r) => r.finished) && player && !player.finished) {
          // Player still racing, don't force end
        }
        updateHud();
      }

      // ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const trk = TRACKS[currentTrack];
        ctx.fillStyle = trk.bg;
        ctx.fillRect(0, 0, GW, GH);
        if (gameState === "title" || gameState === "garage") return;
        const player = racers.find((r) => r.isPlayer);
        if (!player) return;
        const playerScreenY = GH * 0.7;
        const rW = roadW(),
          rL = roadL(),
          lW = laneW();
        // Grass
        ctx.fillStyle = trk.grass;
        ctx.fillRect(0, 0, rL, GH);
        ctx.fillRect(rL + rW, 0, GW - rL - rW, GH);
        // Grass detail
        const grassOff = (player.dist * 0.3) % 40;
        ctx.fillStyle = trk.grassD;
        for (let y = -40 + grassOff; y < GH; y += 40) {
          for (let x = 10; x < rL - 5; x += 25) ctx.fillRect(x, y, 3, 8);
          for (let x = rL + rW + 10; x < GW - 5; x += 25)
            ctx.fillRect(x, y, 3, 8);
        }
        // Road
        ctx.fillStyle = trk.road;
        ctx.fillRect(rL, 0, rW, GH);
        // Road edges
        ctx.fillStyle = trk.edge;
        ctx.fillRect(rL - 2, 0, 3, GH);
        ctx.fillRect(rL + rW - 1, 0, 3, GH);
        // Lane dividers (dashed)
        const dashH = 30,
          gapH = 30,
          scrollOff = player.dist % (dashH + gapH);
        ctx.fillStyle = trk.lane;
        for (let i = 1; i < LANES; i++) {
          const x = rL + i * lW - 1;
          for (let y = -dashH + scrollOff; y < GH; y += dashH + gapH) {
            ctx.fillRect(x, y, 2, dashH);
          }
        }
        // Finish line
        const finishY = playerScreenY - (RACE_DIST - player.dist);
        if (finishY > -20 && finishY < GH + 20) {
          ctx.fillStyle = "#fff";
          for (let i = 0; i < 20; i++) {
            const cx = rL + (i / 20) * rW,
              cy = finishY;
            ctx.fillStyle = i % 2 === 0 ? "#fff" : "#000";
            ctx.fillRect(cx, cy - 5, rW / 20, 10);
          }
        }
        // Roadside Objects
        roadsideObjects.forEach((obj) => {
          const sy = playerScreenY - (obj.dist - player.dist);
          if (sy < -60 || sy > GH + 60) return;
          const sx = obj.isLeft ? rL + obj.offsetX : rL + rW + obj.offsetX;

          ctx.font = obj.size + "px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";

          // Shadow
          ctx.fillStyle = "rgba(0,0,0,0.4)";
          ctx.beginPath();
          ctx.ellipse(
            sx,
            sy,
            obj.size * 0.4,
            obj.size * 0.15,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          ctx.fillStyle = "#fff"; // Default text color for emoji rendering
          ctx.fillText(obj.icon, sx, sy - 2);
        });
        // Items
        raceItems.forEach((it) => {
          if (it.collected) return;
          const sy = playerScreenY - (it.dist - player.dist);
          if (sy < -30 || sy > GH + 30) return;
          const sx = laneX(it.lane);
          ctx.font = "26px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          // Glow
          ctx.shadowColor = "#ffffff";
          ctx.shadowBlur = 15;
          ctx.fillText(it.type.icon, sx, sy - 5); // Shifted slightly up so it's not buried
          ctx.shadowBlur = 0;
        });
        // Oil slicks
        oilSlicks.forEach((o) => {
          const sy = playerScreenY - (o.dist - player.dist);
          if (sy < -30 || sy > GH + 30) return;
          ctx.globalAlpha = Math.min(1, o.life / 3);
          ctx.fillStyle = "#4a2800";
          ctx.beginPath();
          ctx.ellipse(laneX(o.lane), sy, lW * 0.35, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        });
        // Cars
        const sorted = [...racers].sort((a, b) => a.dist - b.dist);
        sorted.forEach((r) => {
          const sy = playerScreenY - (r.dist - player.dist);
          if (sy < -60 || sy > GH + 60) return;
          const sx = r.laneX;
          const cw = lW * 0.55,
            ch = lW * 1.0;
          const hw = cw / 2,
            hh = ch / 2;
          // Shadow
          ctx.fillStyle = "rgba(0,0,0,.3)";
          ctx.beginPath();
          ctx.ellipse(sx, sy + hh + 4, hw * 0.9, 5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.save();
          if (r.spinTimer > 0) {
            ctx.translate(sx, sy);
            ctx.rotate(r.spinTimer * 8);
            ctx.translate(-sx, -sy);
          }
          // Wheels (black with chrome rim)
          const ww = cw * 0.18,
            wh = cw * 0.32;
          const wx = hw + 1,
            wyF = -hh * 0.55,
            wyR = hh * 0.4;
          [
            [-wx, wyF],
            [wx - ww, wyF],
            [-wx, wyR],
            [wx - ww, wyR],
          ].forEach(([ox, oy]) => {
            ctx.fillStyle = "#1a1a1a";
            roundRect(ctx, sx + ox, sy + oy, ww, wh, 2);
            ctx.fill();
            ctx.fillStyle = "rgba(200,200,200,.3)";
            ctx.fillRect(sx + ox + 1, sy + oy + wh * 0.3, ww - 2, 1);
          });
          // Main body (tapered front)
          ctx.fillStyle = r.color;
          ctx.beginPath();
          ctx.moveTo(sx - hw * 0.6, sy - hh); // front left
          ctx.lineTo(sx + hw * 0.6, sy - hh); // front right
          ctx.lineTo(sx + hw, sy - hh * 0.4); // widen
          ctx.lineTo(sx + hw, sy + hh * 0.7); // rear right
          ctx.lineTo(sx + hw * 0.9, sy + hh); // rear corner
          ctx.lineTo(sx - hw * 0.9, sy + hh); // rear left
          ctx.lineTo(sx - hw, sy + hh * 0.7);
          ctx.lineTo(sx - hw, sy - hh * 0.4);
          ctx.closePath();
          ctx.fill();
          // Body highlight (top half)
          ctx.fillStyle = "rgba(255,255,255,.12)";
          ctx.beginPath();
          ctx.moveTo(sx - hw * 0.55, sy - hh);
          ctx.lineTo(sx + hw * 0.55, sy - hh);
          ctx.lineTo(sx + hw * 0.3, sy - hh * 0.1);
          ctx.lineTo(sx - hw * 0.3, sy - hh * 0.1);
          ctx.closePath();
          ctx.fill();
          // Windshield
          ctx.fillStyle = "rgba(80,180,255,.35)";
          ctx.beginPath();
          ctx.moveTo(sx - hw * 0.45, sy - hh * 0.65);
          ctx.lineTo(sx + hw * 0.45, sy - hh * 0.65);
          ctx.lineTo(sx + hw * 0.6, sy - hh * 0.2);
          ctx.lineTo(sx - hw * 0.6, sy - hh * 0.2);
          ctx.closePath();
          ctx.fill();
          // Windshield frame
          ctx.strokeStyle = "rgba(0,0,0,.25)";
          ctx.lineWidth = 0.8;
          ctx.stroke();
          // Rear window
          ctx.fillStyle = "rgba(80,180,255,.25)";
          ctx.beginPath();
          ctx.moveTo(sx - hw * 0.55, sy + hh * 0.1);
          ctx.lineTo(sx + hw * 0.55, sy + hh * 0.1);
          ctx.lineTo(sx + hw * 0.45, sy + hh * 0.35);
          ctx.lineTo(sx - hw * 0.45, sy + hh * 0.35);
          ctx.closePath();
          ctx.fill();
          // Center stripe
          ctx.fillStyle = "rgba(255,255,255,.1)";
          ctx.fillRect(sx - 1, sy - hh, 2, ch);
          // Headlights
          ctx.shadowColor = "#ffeb3b";
          ctx.shadowBlur = 4;
          ctx.fillStyle = "#fff3b0";
          ctx.fillRect(sx - hw * 0.4, sy - hh - 1, cw * 0.12, 3);
          ctx.fillRect(sx + hw * 0.15, sy - hh - 1, cw * 0.12, 3);
          ctx.shadowBlur = 0;
          // Taillights
          ctx.shadowColor = "#f44336";
          ctx.shadowBlur = 3;
          ctx.fillStyle = "#ff1744";
          ctx.fillRect(sx - hw * 0.8, sy + hh - 2, cw * 0.15, 3);
          ctx.fillRect(sx + hw * 0.5, sy + hh - 2, cw * 0.15, 3);
          ctx.shadowBlur = 0;
          // Side mirrors
          ctx.fillStyle = r.color;
          ctx.fillRect(sx - hw - 2, sy - hh * 0.3, 3, 2);
          ctx.fillRect(sx + hw - 1, sy - hh * 0.3, 3, 2);
          // Spoiler (for faster cars)
          if (r.type.maxSpeed >= 220) {
            ctx.fillStyle = "rgba(0,0,0,.4)";
            ctx.fillRect(sx - hw * 0.7, sy + hh - 1, cw * 0.7, 2);
          }
          // Shield glow
          if (r.shieldActive) {
            ctx.strokeStyle = "rgba(0,200,255,.6)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sx, sy, hw * 1.2, hh * 1.1, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          // Boost trail (dual exhaust)
          if (r.boostTimer > 0) {
            const fl = 12 + Math.random() * 10;
            [sx - hw * 0.3, sx + hw * 0.3].forEach((ex) => {
              const grd = ctx.createLinearGradient(
                ex,
                sy + hh,
                ex,
                sy + hh + fl,
              );
              grd.addColorStop(0, "rgba(255,200,50,.8)");
              grd.addColorStop(0.5, "rgba(255,80,0,.5)");
              grd.addColorStop(1, "rgba(255,0,0,0)");
              ctx.fillStyle = grd;
              ctx.beginPath();
              ctx.moveTo(ex - 3, sy + hh);
              ctx.lineTo(ex, sy + hh + fl);
              ctx.lineTo(ex + 3, sy + hh);
              ctx.fill();
            });
          }
          // Stun indicator
          if (r.stunTimer > 0 && r.spinTimer <= 0) {
            ctx.font = "10px serif";
            ctx.textAlign = "center";
            ctx.fillText("\ud83d\udcab", sx, sy - hh - 8);
          }
          ctx.restore();
          // HP bar
          const bw = cw * 1.1,
            bh = 3,
            bx = sx - bw / 2,
            by = sy - hh - 7;
          ctx.fillStyle = "#222";
          roundRect(ctx, bx, by, bw, bh, 1);
          ctx.fill();
          const hr = Math.max(0, r.hp / r.maxHp);
          ctx.fillStyle =
            hr > 0.5 ? "#4CAF50" : hr > 0.25 ? "#FF9800" : "#f44336";
          ctx.fillRect(bx + 0.5, by + 0.5, (bw - 1) * hr, bh - 1);
          // Player indicator
          if (r.isPlayer) {
            ctx.fillStyle = "#e040fb";
            ctx.font = "bold 8px Outfit";
            ctx.textAlign = "center";
            ctx.fillText("\u25bc YOU", sx, sy - hh - 13);
          }
        });
        // Projectiles
        projectiles.forEach((p) => {
          const sy = playerScreenY - (p.dist - player.dist);
          if (sy < -20 || sy > GH + 20) return;
          ctx.fillStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(p.x, sy, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        });
        // Particles
        particles.forEach((p) => {
          const sy = playerScreenY - (p.dist - player.dist);
          if (sy < -20 || sy > GH + 20) return;
          ctx.globalAlpha = p.life / 20;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x + (Math.random() - 0.5) * 5, sy, p.sz, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;
        // Minimap
        const mmW = 30,
          mmH = GH * 0.3,
          mmX = GW - mmW - 8,
          mmY = GH * 0.35;
        ctx.fillStyle = "rgba(0,0,0,.5)";
        roundRect(ctx, mmX - 2, mmY - 2, mmW + 4, mmH + 4, 5);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,.1)";
        ctx.fillRect(mmX, mmY, mmW, mmH);
        racers.forEach((r) => {
          const my = mmY + mmH - (r.dist / RACE_DIST) * mmH;
          ctx.fillStyle = r.isPlayer ? "#e040fb" : r.color;
          ctx.fillRect(
            mmX + 4,
            Math.max(mmY, Math.min(mmY + mmH - 4, my)),
            mmW - 8,
            4,
          );
        });
        // Speed lines
        if (player.speed > 150) {
          ctx.globalAlpha = (player.speed - 150) / 200;
          ctx.strokeStyle = "rgba(255,255,255,.3)";
          ctx.lineWidth = 1;
          for (let i = 0; i < 5; i++) {
            const sx = Math.random() * GW,
              sly = Math.random() * GH;
            ctx.beginPath();
            ctx.moveTo(sx, sly);
            ctx.lineTo(sx, sly + 20 + player.speed * 0.1);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }
      }
      function roundRect(c, x, y, w, h, r) {
        c.beginPath();
        c.moveTo(x + r, y);
        c.lineTo(x + w - r, y);
        c.quadraticCurveTo(x + w, y, x + w, y + r);
        c.lineTo(x + w, y + h - r);
        c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        c.lineTo(x + r, y + h);
        c.quadraticCurveTo(x, y + h, x, y + h - r);
        c.lineTo(x, y + r);
        c.quadraticCurveTo(x, y, x + r, y);
        c.closePath();
      }

      // ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ
      function loop(ts) {
        const dt = Math.min((ts - lastTime) / 1000, 0.1);
        lastTime = ts;
        update(dt);
        render();
        if (gameState === "racing" || gameState === "finishing")
          requestAnimationFrame(loop);
      }

      // ‚îÄ‚îÄ END RACE ‚îÄ‚îÄ
      function endRace() {
        gameState = "result";
        // Fill finish order for unfinished racers
        const unfinished = racers
          .filter((r) => !r.finished)
          .sort((a, b) => b.dist - a.dist);
        unfinished.forEach((r) => {
          finishOrder.push(r);
          r.finishPos = finishOrder.length;
        });
        const player = racers.find((r) => r.isPlayer);
        const pos = player.finishPos;

        // --- KHUNO Reward Logic ---
        let khunoReward = 0;
        if (pos === 1) khunoReward = 5;
        else if (pos === 2) khunoReward = 4;
        else if (pos === 3) khunoReward = 3;
        else if (pos === 4) khunoReward = 2;
        else if (pos === 5) khunoReward = 1;

        khunoCoins += khunoReward;
        localStorage.setItem("khunoCoins", khunoCoins);
        document.getElementById("titleCoins").textContent = khunoCoins;
        document.getElementById("garageCoins").textContent = khunoCoins;
        save();
        // -------------------------

        const suf = ["st", "nd", "rd"][pos - 1] || "th";
        document.getElementById("resultTitle").textContent =
          pos <= 3 ? "üèÜ " + pos + suf + " PLACE!" : "üèÅ RACE COMPLETE";
        document.getElementById("resultTitle").style.color =
          pos === 1 ? "#ffd700" : pos <= 3 ? "#76ff03" : "#fff";
        document.getElementById("resultSub").textContent =
          "You finished " + pos + suf + "!";
        let stand = "";
        finishOrder.forEach((r, i) => {
          let rwd = 0;
          if (i === 0) rwd = 5;
          else if (i === 1) rwd = 4;
          else if (i === 2) rwd = 3;
          else if (i === 3) rwd = 2;
          else if (i === 4) rwd = 1;
          stand += `<div class="srow ${r.isPlayer ? "me" : ""}">${i + 1}. ${r.type.icon} ${r.type.name} ${r.isPlayer ? "(YOU)" : ""} ‚Äî ${rwd} K</div>`;
        });
        document.getElementById("resultStandings").innerHTML = stand;
        document.getElementById("resultInfo").innerHTML =
          "+" + khunoReward + " üí∞ KHUNO earned";
        document.getElementById("resultOverlay").classList.add("active");
      }
      function backToGarage() {
        document.getElementById("resultOverlay").classList.remove("active");
        showGarage();
      }

      // ‚îÄ‚îÄ EXIT RACE ‚îÄ‚îÄ
      function exitRace() {
        if (confirm("‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏™‡∏ô‡∏≤‡∏°‡πÅ‡∏Ç‡πà‡∏á?")) {
          if (window.countdownInterval) clearInterval(window.countdownInterval);
          document.getElementById("countdown").style.display = "none";
          gameState = "garage";
          showGarage();
        }
      }

      // ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ
      addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") {
          e.preventDefault();
          keys.up = true;
        }
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
        if (e.key === " ") useSpecial();
      });
      addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });
      // Touch
      function addTouch(id, onStart, onEnd) {
        const el = document.getElementById(id);
        el.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            onStart();
          },
          { passive: false },
        );
        el.addEventListener("touchend", () => onEnd());
        el.addEventListener("mousedown", () => onStart());
        el.addEventListener("mouseup", () => onEnd());
      }
      addTouch(
        "btnUp",
        () => (touchU = true),
        () => (touchU = false),
      );
      addTouch(
        "btnDown",
        () => (touchD = true),
        () => (touchD = false),
      );
      addTouch(
        "btnLeft",
        () => (touchL = true),
        () => (touchL = false),
      );
      addTouch(
        "btnRight",
        () => (touchR = true),
        () => (touchR = false),
      );
      addEventListener("mouseup", () => {
        touchU = touchD = touchL = touchR = false;
      });

      // ‚îÄ‚îÄ INIT ‚îÄ‚îÄ
      load();
      document.getElementById("titleCoins").textContent = khunoCoins;
      lastTime = performance.now();
      // Render loop for non-racing states
      function bgLoop() {
        if (gameState !== "racing" && gameState !== "finishing") {
          render();
        }
        requestAnimationFrame(bgLoop);
      }
      bgLoop();
    </script>
  </body>
</html>
