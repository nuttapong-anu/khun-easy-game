<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
    />
    <title>Road Rage Racing</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #111;
        font-family: "Outfit", sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        position: fixed;
        top: 0;
        left: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
      .screen {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        align-items: center;
        z-index: 100;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      .screen.active {
        display: flex;
      }
      #titleScreen {
        justify-content: center;
        background: radial-gradient(ellipse at center, #1a0a2e 0%, #0a0a1e 70%);
      }
      #titleScreen h1 {
        font-size: clamp(1.6rem, 5vw, 3rem);
        color: #fff;
        text-shadow:
          0 0 30px #e040fb,
          0 0 60px #e040fb;
        margin-bottom: 8px;
        animation: glow 2s ease-in-out infinite alternate;
        text-align: center;
      }
      #titleScreen h2 {
        font-size: clamp(0.8rem, 2.5vw, 1.1rem);
        color: #ff4081;
        margin-bottom: 30px;
        letter-spacing: 3px;
      }
      @keyframes glow {
        from {
          text-shadow:
            0 0 20px #e040fb,
            0 0 40px #e040fb;
        }
        to {
          text-shadow:
            0 0 40px #ff4081,
            0 0 80px #ff4081;
        }
      }
      .btn-main {
        padding: 14px 44px;
        font-size: clamp(1rem, 3vw, 1.3rem);
        background: linear-gradient(135deg, #e040fb, #ff4081);
        color: #fff;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-weight: bold;
        letter-spacing: 2px;
        box-shadow: 0 0 25px rgba(224, 64, 251, 0.5);
        transition: all 0.3s;
        font-family: inherit;
      }
      .btn-main:hover {
        transform: scale(1.08);
      }
      .home-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 10px 20px;
        border-radius: 30px;
        text-decoration: none;
        font-weight: bold;
        color: #fff;
        z-index: 200;
        transition: all 0.2s;
        font-size: 0.9rem;
      }
      .home-btn:hover {
        transform: scale(1.05);
        background: rgba(255, 255, 255, 0.2);
      }
      .coin-display {
        margin-top: 20px;
        padding: 10px 25px;
        border-radius: 16px;
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid rgba(255, 215, 0, 0.2);
        color: #ffd700;
        font-size: clamp(0.85rem, 2vw, 1.1rem);
        font-weight: bold;
      }
      #garageScreen {
        background: linear-gradient(180deg, #0a0a1e, #1a0a2e);
        padding: 15px 10px 100px;
      }
      .shop-header {
        text-align: center;
        margin: 10px 0 15px;
        width: 100%;
      }
      .shop-header h2 {
        font-size: 1.6rem;
        color: #fff;
        margin-bottom: 5px;
      }
      .shop-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        width: 100%;
        max-width: 600px;
        padding: 0 5px;
      }
      .car-card {
        background: rgba(255, 255, 255, 0.06);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 12px;
        text-align: center;
        color: #fff;
        transition: all 0.3s;
        cursor: pointer;
      }
      .car-card.owned {
        border-color: rgba(76, 175, 80, 0.5);
        background: rgba(76, 175, 80, 0.08);
      }
      .car-card.selected {
        border-color: #e040fb;
        background: rgba(224, 64, 251, 0.15);
        box-shadow: 0 0 15px rgba(224, 64, 251, 0.3);
      }
      .car-icon {
        font-size: 2.2rem;
        margin-bottom: 4px;
      }
      .car-name {
        font-weight: 800;
        font-size: 0.95rem;
        margin-bottom: 4px;
      }
      .car-stats {
        font-size: 0.6rem;
        opacity: 0.7;
        line-height: 1.5;
        margin-bottom: 8px;
      }
      .shop-buy {
        padding: 6px 16px;
        border: none;
        border-radius: 20px;
        background: linear-gradient(135deg, #e040fb, #ff4081);
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        font-size: 0.8rem;
        font-family: inherit;
        transition: all 0.2s;
      }
      .shop-buy:hover {
        transform: scale(1.05);
      }
      .shop-buy:disabled {
        background: #555;
        cursor: not-allowed;
        transform: none;
      }
      .shop-badge {
        color: #4caf50;
        font-weight: bold;
        font-size: 0.8rem;
      }
      .shop-bottom {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: 15px;
        background: linear-gradient(transparent, #0a0a1e 30%);
        display: flex;
        justify-content: center;
        z-index: 10;
      }
      #raceHud {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 8px 12px;
        display: none;
        z-index: 50;
        background: linear-gradient(rgba(0, 0, 0, 0.7), transparent);
        pointer-events: none;
      }
      .hud-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }
      .hud-item {
        padding: 4px 10px;
        border-radius: 20px;
        font-size: clamp(0.6rem, 1.7vw, 0.8rem);
        font-weight: bold;
        white-space: nowrap;
      }
      .hud-pos {
        background: rgba(224, 64, 251, 0.2);
        color: #e040fb;
      }
      .hud-speed {
        background: rgba(255, 152, 0, 0.15);
        color: #ff9800;
      }
      .hud-hp {
        background: rgba(244, 67, 54, 0.15);
        color: #ef5350;
      }
      .hud-special {
        background: rgba(255, 215, 0, 0.15);
        color: #ffd700;
        pointer-events: auto;
        cursor: pointer;
        border: 1px solid rgba(255, 215, 0, 0.3);
      }
      #touchControls {
        position: fixed;
        bottom: 15px;
        left: 0;
        width: 100%;
        display: none;
        justify-content: space-between;
        align-items: flex-end;
        padding: 0 15px;
        z-index: 60;
        pointer-events: none;
      }
      .touch-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        pointer-events: auto;
      }
      .touch-row {
        display: flex;
        gap: 8px;
      }
      .touch-btn {
        width: 65px;
        height: 65px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.12);
        border: 2px solid rgba(255, 255, 255, 0.25);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.8rem;
        color: rgba(255, 255, 255, 0.6);
        pointer-events: auto;
      }
      @media (max-width: 768px) {
        #touchControls {
          display: flex;
        }
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        background: rgba(0, 0, 0, 0.85);
        text-align: center;
        padding: 20px;
        color: #fff;
      }
      .overlay.active {
        display: flex;
      }
      .overlay h2 {
        font-size: clamp(1.5rem, 5vw, 2.5rem);
        margin-bottom: 15px;
      }
      .overlay .sub {
        font-size: clamp(1rem, 3vw, 1.3rem);
        margin-bottom: 8px;
      }
      .overlay .info {
        font-size: clamp(0.8rem, 2vw, 1rem);
        color: #aaa;
        margin-bottom: 20px;
      }
      .standings {
        text-align: left;
        margin-bottom: 20px;
        font-size: clamp(0.7rem, 2vw, 0.9rem);
      }
      .standings .srow {
        padding: 4px 14px;
        border-radius: 8px;
        margin: 3px 0;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .standings .srow.me {
        background: rgba(224, 64, 251, 0.2);
        border: 1px solid rgba(224, 64, 251, 0.3);
      }
      #countdown {
        position: fixed;
        top: 35%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 150;
        font-size: clamp(3rem, 10vw, 6rem);
        color: #fff;
        font-weight: 800;
        text-shadow: 0 0 40px #e040fb;
        display: none;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="titleScreen" class="screen active">
      <a href="index.html" class="home-btn">üè† Home</a>
      <h1>üèÅ ROAD RAGE</h1>
      <h2>RACING</h2>
      <button class="btn-main" onclick="showGarage()">‚ñ∂ START</button>
      <div class="coin-display" id="titleCoins">ü™ô 0</div>
    </div>
    <div id="garageScreen" class="screen">
      <a href="index.html" class="home-btn">üè† Home</a>
      <div class="shop-header">
        <h2>üîß GARAGE</h2>
        <div class="coin-display" id="garageCoins">ü™ô 0</div>
      </div>
      <div class="shop-grid" id="carGrid"></div>
      <div class="shop-bottom">
        <button class="btn-main" onclick="startRace()">üèÅ RACE!</button>
      </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="raceHud">
      <div class="hud-row">
        <span class="hud-item hud-pos" id="hudPos">POS 1/7</span>
        <span class="hud-item hud-speed" id="hudSpeed">0 km/h</span>
        <span class="hud-item hud-hp" id="hudHp">‚ù§Ô∏è 100</span>
        <span
          class="hud-item hud-special"
          id="hudSpecial"
          onclick="useSpecial()"
          >üì¶ ---</span
        >
      </div>
    </div>
    <div id="touchControls">
      <div class="touch-group">
        <div class="touch-btn" id="btnUp">‚ñ≤</div>
        <div class="touch-btn" id="btnDown">‚ñº</div>
      </div>
      <div class="touch-group">
        <div class="touch-row">
          <div class="touch-btn" id="btnLeft">‚óÄ</div>
          <div class="touch-btn" id="btnRight">‚ñ∂</div>
        </div>
      </div>
    </div>
    <div id="resultOverlay" class="overlay">
      <h2 id="resultTitle">üèÅ RACE COMPLETE</h2>
      <div class="sub" id="resultSub"></div>
      <div class="standings" id="resultStandings"></div>
      <div class="info" id="resultInfo"></div>
      <button class="btn-main" onclick="backToGarage()">üîß Garage</button>
    </div>
    <div id="countdown"></div>

    <script>
      // ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ
      const RACE_DIST = 12000,
        NUM_RACERS = 5,
        LANES = 5;
      const REWARDS = [150, 100, 70, 40, 15];
      const CARS = [
        {
          id: "runner",
          name: "Runner",
          icon: "üöó",
          cost: 0,
          maxSpeed: 200,
          accel: 30,
          hp: 100,
          handling: 5,
          weapon: "minigun",
          color: "#4CAF50",
          desc: "Balanced starter",
        },
        {
          id: "blaze",
          name: "Blaze",
          icon: "üèéÔ∏è",
          cost: 120,
          maxSpeed: 240,
          accel: 40,
          hp: 70,
          handling: 6,
          weapon: "flame",
          color: "#FF5722",
          desc: "Fast & fragile",
        },
        {
          id: "titan",
          name: "Titan",
          icon: "üöõ",
          cost: 250,
          maxSpeed: 165,
          accel: 22,
          hp: 200,
          handling: 3,
          weapon: "cannon",
          color: "#607D8B",
          desc: "Slow but tough",
        },
        {
          id: "storm",
          name: "Storm",
          icon: "‚ö°",
          cost: 400,
          maxSpeed: 260,
          accel: 50,
          hp: 60,
          handling: 8,
          weapon: "shock",
          color: "#FF9800",
          desc: "Lightning speed",
        },
        {
          id: "shadow",
          name: "Shadow",
          icon: "üåë",
          cost: 600,
          maxSpeed: 220,
          accel: 35,
          hp: 90,
          handling: 6,
          weapon: "homing",
          color: "#9C27B0",
          desc: "Stealth tracker",
        },
        {
          id: "fury",
          name: "Fury",
          icon: "üíÄ",
          cost: 900,
          maxSpeed: 240,
          accel: 38,
          hp: 150,
          handling: 5,
          weapon: "rockets",
          color: "#f44336",
          desc: "Devastating power",
        },
      ];
      const WEAPONS = {
        minigun: { dmg: 5, rate: 0.15, speed: 600, color: "#ffeb3b" },
        flame: { dmg: 3, rate: 0.08, speed: 400, color: "#ff5722" },
        cannon: { dmg: 20, rate: 0.8, speed: 500, color: "#90a4ae" },
        shock: { dmg: 10, rate: 0.35, speed: 700, color: "#ff9800" },
        homing: { dmg: 15, rate: 0.6, speed: 350, color: "#ce93d8" },
        rockets: { dmg: 12, rate: 0.4, speed: 550, color: "#ef5350" },
      };
      const ITEM_TYPES = [
        { id: "boost", icon: "üöÄ", name: "Boost" },
        { id: "shield", icon: "üõ°Ô∏è", name: "Shield" },
        { id: "rocket", icon: "üî•", name: "Rocket" },
        { id: "zap", icon: "‚ö°", name: "Zap" },
        { id: "oil", icon: "üõ¢Ô∏è", name: "Oil" },
        { id: "repair", icon: "‚ù§Ô∏è", name: "Repair" },
      ];

      // ‚îÄ‚îÄ CANVAS ‚îÄ‚îÄ
      const canvas = document.getElementById("gameCanvas"),
        ctx = canvas.getContext("2d");
      let GW, GH;
      function resize() {
        canvas.width = innerWidth;
        canvas.height = innerHeight;
        GW = innerWidth;
        GH = innerHeight;
      }
      resize();
      addEventListener("resize", resize);

      // ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
      let coins = 0,
        ownedCars = ["runner"],
        selectedCar = "runner",
        gameState = "title";
      let racers = [],
        raceItems = [],
        projectiles = [],
        particles = [],
        oilSlicks = [];
      let keys = { up: false, down: false, left: false, right: false };
      let touchU = false,
        touchD = false,
        touchL = false,
        touchR = false;
      let lastTime = 0,
        raceTime = 0,
        finishOrder = [];

      // ‚îÄ‚îÄ PERSISTENCE ‚îÄ‚îÄ
      function save() {
        localStorage.setItem("rr_coins", coins);
        localStorage.setItem("rr_owned", JSON.stringify(ownedCars));
        localStorage.setItem("rr_selected", selectedCar);
      }
      function load() {
        coins = parseInt(localStorage.getItem("rr_coins") || "0");
        try {
          ownedCars = JSON.parse(localStorage.getItem("rr_owned")) || [
            "runner",
          ];
        } catch (e) {
          ownedCars = ["runner"];
        }
        if (!ownedCars.includes("runner")) ownedCars.unshift("runner");
        selectedCar = localStorage.getItem("rr_selected") || "runner";
        if (!ownedCars.includes(selectedCar)) selectedCar = "runner";
      }

      // ‚îÄ‚îÄ SCREEN ‚îÄ‚îÄ
      function showScreen(id) {
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        ["raceHud", "touchControls"].forEach(
          (i) => (document.getElementById(i).style.display = "none"),
        );
        document
          .querySelectorAll(".overlay")
          .forEach((o) => o.classList.remove("active"));
        if (id) document.getElementById(id).classList.add("active");
      }
      function showGarage() {
        showScreen("garageScreen");
        gameState = "garage";
        renderGarage();
      }
      function renderGarage() {
        const g = document.getElementById("carGrid");
        g.innerHTML = "";
        CARS.forEach((car) => {
          const own = ownedCars.includes(car.id),
            sel = selectedCar === car.id,
            aff = coins >= car.cost;
          g.innerHTML += `<div class="car-card ${own ? "owned" : ""} ${sel ? "selected" : ""}" onclick="${own ? `selectCar('${car.id}')` : ""}">
      <div class="car-icon">${car.icon}</div><div class="car-name">${car.name}</div>
      <div class="car-stats">SPD ${car.maxSpeed} ¬∑ ACC ${car.accel}<br>HP ${car.hp} ¬∑ HND ${car.handling}<br>${car.desc}</div>
      ${
        own
          ? sel
            ? '<div class="shop-badge">‚úì SELECTED</div>'
            : '<div class="shop-badge" style="color:#aaa">OWNED</div>'
          : `<button class="shop-buy" ${!aff ? "disabled" : ""} onclick="event.stopPropagation();buyCar('${car.id}')">${car.cost === 0 ? "FREE" : "ü™ô" + car.cost}</button>`
      }
    </div>`;
        });
        document.getElementById("garageCoins").textContent = "ü™ô " + coins;
        document.getElementById("titleCoins").textContent = "ü™ô " + coins;
      }
      function selectCar(id) {
        selectedCar = id;
        save();
        renderGarage();
      }
      function buyCar(id) {
        const c = CARS.find((x) => x.id === id);
        if (!c || ownedCars.includes(id) || coins < c.cost) return;
        coins -= c.cost;
        ownedCars.push(id);
        selectedCar = id;
        save();
        renderGarage();
      }

      // ‚îÄ‚îÄ ROAD HELPERS ‚îÄ‚îÄ
      function roadW() {
        return GW * 0.65;
      }
      function roadL() {
        return (GW - roadW()) / 2;
      }
      function laneW() {
        return roadW() / LANES;
      }
      function laneX(l) {
        return roadL() + (l + 0.5) * laneW();
      }

      // ‚îÄ‚îÄ RACER ‚îÄ‚îÄ
      class Racer {
        constructor(type, lane, isPlayer) {
          this.type = type;
          this.isPlayer = isPlayer;
          this.dist = 0;
          this.lane = lane;
          this.targetLane = lane;
          this.laneX = laneX(lane);
          this.speed = 0;
          this.maxSpeed = type.maxSpeed;
          this.accel = type.accel;
          this.hp = type.hp;
          this.maxHp = type.hp;
          this.handling = type.handling;
          this.weaponTimer = 0;
          this.stunTimer = 0;
          this.boostTimer = 0;
          this.oilTimer = 0;
          this.shieldActive = false;
          this.special = null;
          this.finished = false;
          this.finishPos = 0;
          this.spinTimer = 0;
          this.color = type.color;
          this.aiLT = 2 + Math.random() * 3;
        }
        get effMax() {
          let s = this.maxSpeed;
          if (this.boostTimer > 0) s *= 1.4;
          if (this.oilTimer > 0) s *= 0.5;
          if (this.stunTimer > 0) s *= 0.15;
          return s;
        }
        update(dt) {
          if (this.finished) {
            this.speed = Math.max(0, this.speed - 100 * dt);
            return;
          }
          if (this.stunTimer > 0) this.stunTimer -= dt;
          if (this.boostTimer > 0) this.boostTimer -= dt;
          if (this.oilTimer > 0) this.oilTimer -= dt;
          if (this.spinTimer > 0) {
            this.spinTimer -= dt;
            this.speed = Math.max(0, this.speed - 150 * dt);
            return;
          }
          this.weaponTimer -= dt;
          const em = this.effMax;
          if (this.isPlayer) {
            if (keys.up || touchU)
              this.speed = Math.min(em, this.speed + this.accel * dt * 2);
            else if (keys.down || touchD)
              this.speed = Math.max(0, this.speed - this.accel * dt * 4);
            else this.speed = Math.min(em, this.speed + this.accel * dt * 0.5);
            if (keys.left || touchL) {
              if (this.targetLane > 0 && this.lane === this.targetLane)
                this.targetLane--;
            }
            if (keys.right || touchR) {
              if (this.targetLane < LANES - 1 && this.lane === this.targetLane)
                this.targetLane++;
            }
          } else {
            this.aiUpdate(dt);
          }
          this.speed = Math.max(0, Math.min(em, this.speed));
          this.dist += this.speed * dt;
          // Lane transition
          const tx = laneX(this.targetLane);
          const dx = tx - this.laneX;
          if (Math.abs(dx) > 1) {
            this.laneX += Math.sign(dx) * this.handling * 60 * dt;
          } else {
            this.laneX = tx;
            this.lane = this.targetLane;
          }
          if (this.dist >= RACE_DIST && !this.finished) {
            this.finished = true;
            finishOrder.push(this);
            this.finishPos = finishOrder.length;
          }
        }
        aiUpdate(dt) {
          const p = racers.find((r) => r.isPlayer);
          let ts = this.maxSpeed * (0.85 + Math.random() * 0.3);
          if (p && this.dist > p.dist + 800) ts *= 0.88;
          if (p && this.dist < p.dist - 600) ts *= 1.12;
          ts = Math.min(ts, this.effMax);
          if (this.speed < ts) this.speed += this.accel * dt;
          else this.speed -= this.accel * dt * 0.5;
          this.aiLT -= dt;
          if (this.aiLT <= 0) {
            this.aiLT = 1.5 + Math.random() * 3;
            let best = this.lane;
            for (let it of raceItems) {
              if (
                !it.collected &&
                it.dist > this.dist &&
                it.dist < this.dist + 400
              ) {
                best = it.lane;
                break;
              }
            }
            if (Math.random() < 0.3)
              best = Math.max(
                0,
                Math.min(LANES - 1, this.lane + (Math.random() < 0.5 ? -1 : 1)),
              );
            this.targetLane = best;
          }
          if (this.special && Math.random() < 0.005) this.useSpecialItem();
          // AI weapon fire
          if (this.weaponTimer <= 0) {
            const w = WEAPONS[this.type.weapon];
            let tgt = null,
              bd = Infinity;
            racers.forEach((r) => {
              if (
                r !== this &&
                !r.finished &&
                r.dist > this.dist &&
                r.dist < this.dist + 400
              ) {
                const d = r.dist - this.dist;
                if (d < bd) {
                  bd = d;
                  tgt = r;
                }
              }
            });
            if (tgt) {
              projectiles.push({
                x: this.laneX,
                y: 0,
                dist: this.dist,
                speed: w.speed,
                dmg: w.dmg,
                color: w.color,
                owner: this,
                target: tgt,
              });
              this.weaponTimer = w.rate;
            }
          }
        }
        hit(dmg) {
          if (this.shieldActive) {
            this.shieldActive = false;
            return;
          }
          this.hp -= dmg;
          this.stunTimer = Math.max(this.stunTimer, 0.3);
          if (this.hp <= 0) {
            this.hp = Math.floor(this.maxHp * 0.3);
            this.spinTimer = 1.5;
            this.speed *= 0.3;
          }
        }
        useSpecialItem() {
          if (!this.special) return;
          const s = this.special;
          this.special = null;
          if (s === "boost") {
            this.boostTimer = 3;
          } else if (s === "shield") {
            this.shieldActive = true;
          } else if (s === "rocket") {
            let tgt = null,
              bd = Infinity;
            racers.forEach((r) => {
              if (r !== this && !r.finished && r.dist > this.dist) {
                const d = r.dist - this.dist;
                if (d < bd) {
                  bd = d;
                  tgt = r;
                }
              }
            });
            if (tgt)
              projectiles.push({
                x: this.laneX,
                y: 0,
                dist: this.dist,
                speed: 800,
                dmg: 25,
                color: "#ff1744",
                owner: this,
                target: tgt,
              });
          } else if (s === "zap") {
            racers.forEach((r) => {
              if (
                r !== this &&
                !r.finished &&
                Math.abs(r.dist - this.dist) < 300
              )
                r.stunTimer = 1.5;
            });
            for (let i = 0; i < 15; i++)
              particles.push({
                x: this.laneX + (Math.random() - 0.5) * 100,
                dist: this.dist + (Math.random() - 0.5) * 200,
                life: 20,
                color: "#ffeb3b",
                sz: 3,
              });
          } else if (s === "oil") {
            oilSlicks.push({ lane: this.lane, dist: this.dist - 50, life: 15 });
          } else if (s === "repair") {
            this.hp = Math.min(this.maxHp, this.hp + 40);
          }
          updateHud();
        }
      }

      // ‚îÄ‚îÄ RACE INIT ‚îÄ‚îÄ
      function startRace() {
        showScreen(null);
        gameState = "countdown";
        racers = [];
        projectiles = [];
        particles = [];
        oilSlicks = [];
        raceItems = [];
        finishOrder = [];
        raceTime = 0;
        const playerType = CARS.find((c) => c.id === selectedCar) || CARS[0];
        const pl = new Racer(playerType, 2, true);
        racers.push(pl);
        // AI cars
        const aiTypes = CARS.filter((c) => c.id !== selectedCar);
        for (let i = 0; i < NUM_RACERS - 1; i++) {
          const t = aiTypes[i % aiTypes.length];
          const lane = i < 2 ? i : i + 1 >= LANES ? i % LANES : i + 1;
          racers.push(new Racer(t, lane % LANES, false));
        }
        // Generate items
        for (let d = 300; d < RACE_DIST - 500; d += 120 + Math.random() * 180) {
          raceItems.push({
            dist: d,
            lane: Math.floor(Math.random() * LANES),
            type: ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)],
            collected: false,
          });
        }
        document.getElementById("raceHud").style.display = "block";
        document.getElementById("touchControls").style.display = "flex";
        // Countdown
        let c = 3;
        const el = document.getElementById("countdown");
        el.style.display = "block";
        el.textContent = c;
        const ci = setInterval(() => {
          c--;
          if (c > 0) {
            el.textContent = c;
          } else if (c === 0) {
            el.textContent = "GO!";
            el.style.color = "#76ff03";
          } else {
            clearInterval(ci);
            el.style.display = "none";
            el.style.color = "#fff";
            gameState = "racing";
            lastTime = performance.now();
            requestAnimationFrame(loop);
          }
        }, 800);
      }

      function updateHud() {
        const p = racers.find((r) => r.isPlayer);
        if (!p) return;
        const sorted = [...racers].sort((a, b) => b.dist - a.dist);
        const pos = sorted.indexOf(p) + 1;
        const suf = ["st", "nd", "rd"][pos - 1] || "th";
        document.getElementById("hudPos").textContent =
          pos + suf + " / " + NUM_RACERS;
        document.getElementById("hudSpeed").textContent =
          Math.round(p.speed) + " km/h";
        document.getElementById("hudHp").textContent =
          "‚ù§Ô∏è " + Math.max(0, Math.round(p.hp));
        document.getElementById("hudSpecial").textContent = p.special
          ? ITEM_TYPES.find((i) => i.id === p.special).icon + " USE"
          : "üì¶ ---";
      }

      function useSpecial() {
        const p = racers.find((r) => r.isPlayer);
        if (p) p.useSpecialItem();
      }

      // ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ
      function update(dt) {
        if (gameState !== "racing") return;
        raceTime += dt;
        const player = racers.find((r) => r.isPlayer);
        // Update racers
        racers.forEach((r) => r.update(dt));
        // Player weapon auto-fire
        if (
          player &&
          player.weaponTimer <= 0 &&
          !player.finished &&
          player.spinTimer <= 0
        ) {
          const w = WEAPONS[player.type.weapon];
          let tgt = null,
            bd = Infinity;
          racers.forEach((r) => {
            if (
              r !== player &&
              !r.finished &&
              r.dist > player.dist &&
              r.dist < player.dist + 400
            ) {
              const d = r.dist - player.dist;
              if (d < bd) {
                bd = d;
                tgt = r;
              }
            }
          });
          if (tgt) {
            projectiles.push({
              x: player.laneX,
              y: 0,
              dist: player.dist,
              speed: w.speed,
              dmg: w.dmg,
              color: w.color,
              owner: player,
              target: tgt,
            });
            player.weaponTimer = w.rate;
          }
        }
        // Projectiles
        projectiles = projectiles.filter((p) => {
          p.dist += p.speed * dt;
          // Check hit target
          if (p.target && !p.target.finished) {
            if (
              Math.abs(p.dist - p.target.dist) < 30 &&
              Math.abs(p.x - p.target.laneX) < laneW() * 0.6
            ) {
              p.target.hit(p.dmg);
              for (let i = 0; i < 5; i++)
                particles.push({
                  x: p.target.laneX + (Math.random() - 0.5) * 20,
                  dist: p.target.dist,
                  life: 15,
                  color: p.color,
                  sz: 2 + Math.random() * 3,
                });
              return false;
            }
          }
          return (
            p.dist < (player ? player.dist + GH : 0) &&
            p.dist > (player ? player.dist : 0) - 200
          );
        });
        // Item collection
        raceItems.forEach((it) => {
          if (it.collected) return;
          racers.forEach((r) => {
            if (
              !r.finished &&
              r.lane === it.lane &&
              Math.abs(r.dist - it.dist) < 25
            ) {
              it.collected = true;
              if (!r.special) r.special = it.type.id;
              else {
                // Auto-use if already have one
                const old = r.special;
                r.special = it.type.id;
                r.useSpecialItem();
              }
              for (let i = 0; i < 8; i++)
                particles.push({
                  x: laneX(it.lane) + (Math.random() - 0.5) * 30,
                  dist: it.dist,
                  life: 20,
                  color: "#ffd700",
                  sz: 2 + Math.random() * 2,
                });
            }
          });
        });
        // Oil slicks
        oilSlicks = oilSlicks.filter((o) => {
          o.life -= dt;
          racers.forEach((r) => {
            if (
              !r.finished &&
              r.lane === o.lane &&
              Math.abs(r.dist - o.dist) < 30 &&
              r.oilTimer <= 0
            ) {
              r.oilTimer = 2;
              r.stunTimer = 0.5;
            }
          });
          return o.life > 0;
        });
        // Bumping
        for (let i = 0; i < racers.length; i++) {
          for (let j = i + 1; j < racers.length; j++) {
            const a = racers[i],
              b = racers[j];
            if (a.finished || b.finished) continue;
            if (
              Math.abs(a.laneX - b.laneX) < laneW() * 0.7 &&
              Math.abs(a.dist - b.dist) < 25
            ) {
              const dmg = Math.abs(a.speed - b.speed) * 0.05 + 2;
              a.hit(dmg);
              b.hit(dmg);
              if (a.dist > b.dist) b.dist -= 5;
              else a.dist -= 5;
            }
          }
        }
        // Particles
        particles = particles.filter((p) => {
          p.life--;
          return p.life > 0;
        });
        // Check race end
        if (player && player.finished) {
          setTimeout(() => endRace(), 500);
          gameState = "finishing";
        }
        // Force-end if all AI finished
        const allAI = racers.filter((r) => !r.isPlayer);
        if (allAI.every((r) => r.finished) && player && !player.finished) {
          // Player still racing, don't force end
        }
        updateHud();
      }

      // ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#1a1a2e";
        ctx.fillRect(0, 0, GW, GH);
        if (gameState === "title" || gameState === "garage") return;
        const player = racers.find((r) => r.isPlayer);
        if (!player) return;
        const playerScreenY = GH * 0.7;
        const rW = roadW(),
          rL = roadL(),
          lW = laneW();
        // Grass
        ctx.fillStyle = "#1a3d0c";
        ctx.fillRect(0, 0, rL, GH);
        ctx.fillRect(rL + rW, 0, GW - rL - rW, GH);
        // Grass detail
        const grassOff = (player.dist * 0.3) % 40;
        ctx.fillStyle = "#245210";
        for (let y = -40 + grassOff; y < GH; y += 40) {
          for (let x = 10; x < rL - 5; x += 25) ctx.fillRect(x, y, 3, 8);
          for (let x = rL + rW + 10; x < GW - 5; x += 25)
            ctx.fillRect(x, y, 3, 8);
        }
        // Road
        ctx.fillStyle = "#333";
        ctx.fillRect(rL, 0, rW, GH);
        // Road edges
        ctx.fillStyle = "#fff";
        ctx.fillRect(rL - 2, 0, 3, GH);
        ctx.fillRect(rL + rW - 1, 0, 3, GH);
        // Lane dividers (dashed)
        const dashH = 30,
          gapH = 30,
          scrollOff = player.dist % (dashH + gapH);
        ctx.fillStyle = "rgba(255,255,255,.2)";
        for (let i = 1; i < LANES; i++) {
          const x = rL + i * lW - 1;
          for (let y = -dashH + scrollOff; y < GH; y += dashH + gapH) {
            ctx.fillRect(x, y, 2, dashH);
          }
        }
        // Finish line
        const finishY = playerScreenY - (RACE_DIST - player.dist);
        if (finishY > -20 && finishY < GH + 20) {
          ctx.fillStyle = "#fff";
          for (let i = 0; i < 20; i++) {
            const cx = rL + (i / 20) * rW,
              cy = finishY;
            ctx.fillStyle = i % 2 === 0 ? "#fff" : "#000";
            ctx.fillRect(cx, cy - 5, rW / 20, 10);
          }
        }
        // Items
        raceItems.forEach((it) => {
          if (it.collected) return;
          const sy = playerScreenY - (it.dist - player.dist);
          if (sy < -30 || sy > GH + 30) return;
          const sx = laneX(it.lane);
          ctx.font = 14 + "px serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          // Glow
          ctx.shadowColor = "#ffd700";
          ctx.shadowBlur = 10;
          ctx.fillText(it.type.icon, sx, sy);
          ctx.shadowBlur = 0;
        });
        // Oil slicks
        oilSlicks.forEach((o) => {
          const sy = playerScreenY - (o.dist - player.dist);
          if (sy < -30 || sy > GH + 30) return;
          ctx.globalAlpha = Math.min(1, o.life / 3);
          ctx.fillStyle = "#4a2800";
          ctx.beginPath();
          ctx.ellipse(laneX(o.lane), sy, lW * 0.35, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        });
        // Cars
        const sorted = [...racers].sort((a, b) => a.dist - b.dist);
        sorted.forEach((r) => {
          const sy = playerScreenY - (r.dist - player.dist);
          if (sy < -60 || sy > GH + 60) return;
          const sx = r.laneX;
          const cw = lW * 0.55,
            ch = lW * 0.9;
          // Shadow
          ctx.fillStyle = "rgba(0,0,0,.3)";
          ctx.beginPath();
          ctx.ellipse(sx, sy + ch * 0.4, cw * 0.5, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          // Car body
          ctx.save();
          if (r.spinTimer > 0)
            (ctx.translate(sx, sy),
              ctx.rotate(r.spinTimer * 8),
              ctx.translate(-sx, -sy));
          ctx.fillStyle = r.color;
          roundRect(ctx, sx - cw / 2, sy - ch / 2, cw, ch, 5);
          ctx.fill();
          // Windshield
          ctx.fillStyle = "rgba(100,200,255,.4)";
          roundRect(ctx, sx - cw * 0.3, sy - ch * 0.25, cw * 0.6, ch * 0.18, 3);
          ctx.fill();
          // Stripe
          ctx.fillStyle = "rgba(255,255,255,.15)";
          ctx.fillRect(sx - 2, sy - ch / 2, 4, ch);
          // Shield glow
          if (r.shieldActive) {
            ctx.strokeStyle = "rgba(0,200,255,.6)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sx, sy, cw * 0.6, ch * 0.55, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          // Boost trail
          if (r.boostTimer > 0) {
            ctx.fillStyle = "rgba(255,100,0,.5)";
            ctx.beginPath();
            ctx.moveTo(sx - cw * 0.3, sy + ch / 2);
            ctx.lineTo(sx, sy + ch / 2 + 15 + Math.random() * 10);
            ctx.lineTo(sx + cw * 0.3, sy + ch / 2);
            ctx.fill();
          }
          // Stun indicator
          if (r.stunTimer > 0 && r.spinTimer <= 0) {
            ctx.font = "10px serif";
            ctx.textAlign = "center";
            ctx.fillText("üí´", sx, sy - ch / 2 - 8);
          }
          ctx.restore();
          // HP bar
          const bw = cw,
            bh = 3,
            bx = sx - bw / 2,
            by = sy - ch / 2 - 6;
          ctx.fillStyle = "#333";
          ctx.fillRect(bx, by, bw, bh);
          const hr = Math.max(0, r.hp / r.maxHp);
          ctx.fillStyle =
            hr > 0.5 ? "#4CAF50" : hr > 0.25 ? "#FF9800" : "#f44336";
          ctx.fillRect(bx, by, bw * hr, bh);
          // Player indicator
          if (r.isPlayer) {
            ctx.fillStyle = "#e040fb";
            ctx.font = "bold 8px Outfit";
            ctx.textAlign = "center";
            ctx.fillText("‚ñº YOU", sx, sy - ch / 2 - 12);
          }
        });
        // Projectiles
        projectiles.forEach((p) => {
          const sy = playerScreenY - (p.dist - player.dist);
          if (sy < -20 || sy > GH + 20) return;
          ctx.fillStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(p.x, sy, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        });
        // Particles
        particles.forEach((p) => {
          const sy = playerScreenY - (p.dist - player.dist);
          if (sy < -20 || sy > GH + 20) return;
          ctx.globalAlpha = p.life / 20;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x + (Math.random() - 0.5) * 5, sy, p.sz, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;
        // Minimap
        const mmW = 30,
          mmH = GH * 0.3,
          mmX = GW - mmW - 8,
          mmY = GH * 0.35;
        ctx.fillStyle = "rgba(0,0,0,.5)";
        roundRect(ctx, mmX - 2, mmY - 2, mmW + 4, mmH + 4, 5);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,.1)";
        ctx.fillRect(mmX, mmY, mmW, mmH);
        racers.forEach((r) => {
          const my = mmY + mmH - (r.dist / RACE_DIST) * mmH;
          ctx.fillStyle = r.isPlayer ? "#e040fb" : r.color;
          ctx.fillRect(
            mmX + 4,
            Math.max(mmY, Math.min(mmY + mmH - 4, my)),
            mmW - 8,
            4,
          );
        });
        // Speed lines
        if (player.speed > 150) {
          ctx.globalAlpha = (player.speed - 150) / 200;
          ctx.strokeStyle = "rgba(255,255,255,.3)";
          ctx.lineWidth = 1;
          for (let i = 0; i < 5; i++) {
            const sx = Math.random() * GW,
              sly = Math.random() * GH;
            ctx.beginPath();
            ctx.moveTo(sx, sly);
            ctx.lineTo(sx, sly + 20 + player.speed * 0.1);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }
      }
      function roundRect(c, x, y, w, h, r) {
        c.beginPath();
        c.moveTo(x + r, y);
        c.lineTo(x + w - r, y);
        c.quadraticCurveTo(x + w, y, x + w, y + r);
        c.lineTo(x + w, y + h - r);
        c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        c.lineTo(x + r, y + h);
        c.quadraticCurveTo(x, y + h, x, y + h - r);
        c.lineTo(x, y + r);
        c.quadraticCurveTo(x, y, x + r, y);
        c.closePath();
      }

      // ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ
      function loop(ts) {
        const dt = Math.min((ts - lastTime) / 1000, 0.1);
        lastTime = ts;
        update(dt);
        render();
        if (gameState === "racing" || gameState === "finishing")
          requestAnimationFrame(loop);
      }

      // ‚îÄ‚îÄ END RACE ‚îÄ‚îÄ
      function endRace() {
        gameState = "result";
        // Fill finish order for unfinished racers
        const unfinished = racers
          .filter((r) => !r.finished)
          .sort((a, b) => b.dist - a.dist);
        unfinished.forEach((r) => {
          finishOrder.push(r);
          r.finishPos = finishOrder.length;
        });
        const player = racers.find((r) => r.isPlayer);
        const pos = player.finishPos;
        const reward = REWARDS[pos - 1] || 0;
        coins += reward;
        save();
        const suf = ["st", "nd", "rd"][pos - 1] || "th";
        document.getElementById("resultTitle").textContent =
          pos <= 3 ? "üèÜ " + pos + suf + " PLACE!" : "üèÅ RACE COMPLETE";
        document.getElementById("resultTitle").style.color =
          pos === 1 ? "#ffd700" : pos <= 3 ? "#76ff03" : "#fff";
        document.getElementById("resultSub").textContent =
          "You finished " + pos + suf + "!";
        let stand = "";
        finishOrder.forEach((r, i) => {
          stand += `<div class="srow ${r.isPlayer ? "me" : ""}">${i + 1}. ${r.type.icon} ${r.type.name} ${r.isPlayer ? "(YOU)" : ""} ‚Äî ü™ô${REWARDS[i] || 0}</div>`;
        });
        document.getElementById("resultStandings").innerHTML = stand;
        document.getElementById("resultInfo").textContent =
          "+" + reward + " ü™ô earned";
        document.getElementById("resultOverlay").classList.add("active");
      }
      function backToGarage() {
        document.getElementById("resultOverlay").classList.remove("active");
        showGarage();
      }

      // ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ
      addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") {
          e.preventDefault();
          keys.up = true;
        }
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
        if (e.key === " ") useSpecial();
      });
      addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });
      // Touch
      function addTouch(id, onStart, onEnd) {
        const el = document.getElementById(id);
        el.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            onStart();
          },
          { passive: false },
        );
        el.addEventListener("touchend", () => onEnd());
        el.addEventListener("mousedown", () => onStart());
        el.addEventListener("mouseup", () => onEnd());
      }
      addTouch(
        "btnUp",
        () => (touchU = true),
        () => (touchU = false),
      );
      addTouch(
        "btnDown",
        () => (touchD = true),
        () => (touchD = false),
      );
      addTouch(
        "btnLeft",
        () => (touchL = true),
        () => (touchL = false),
      );
      addTouch(
        "btnRight",
        () => (touchR = true),
        () => (touchR = false),
      );
      addEventListener("mouseup", () => {
        touchU = touchD = touchL = touchR = false;
      });

      // ‚îÄ‚îÄ INIT ‚îÄ‚îÄ
      load();
      document.getElementById("titleCoins").textContent = "ü™ô " + coins;
      lastTime = performance.now();
      // Render loop for non-racing states
      function bgLoop() {
        if (gameState !== "racing" && gameState !== "finishing") {
          render();
        }
        requestAnimationFrame(bgLoop);
      }
      bgLoop();
    </script>
  </body>
</html>
